// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6.1 effective-4.2 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 4.2 -enforce-exclusivity=checked -Onone -module-name CPCoreKit
import AVFoundation
import AudioToolbox
import CommonCrypto
import CoreData
import CoreGraphics
import CoreImage
import CoreLocation
import Darwin
import Dispatch
import Foundation
import MapKit
import QuartzCore
import SceneKit
import Security
import SpriteKit
import StoreKit
import Swift
import SystemConfiguration
import UIKit.UIImage
import UIKit
import _Concurrency
import os
@available(iOS 8.0, *)
extension CoreLocation.CLVisit {
  public var location: CoreLocation.CLLocation {
    get
  }
}
extension SceneKit.SCNGeometry {
  public var boundingSize: SceneKit.SCNVector3 {
    get
  }
}
public protocol CPImageProcessing {
  func process(image: CPCoreKit.CPImage, context: CPCoreKit.CPImageProcessingContext?) -> CPCoreKit.CPImage?
  var identifier: Swift.String { get }
  var hashableIdentifier: Swift.AnyHashable { get }
}
extension CPCoreKit.CPImageProcessing {
  public func process(image: CPCoreKit.CPImage) -> CPCoreKit.CPImage?
}
extension CPCoreKit.CPImageProcessing {
  public var hashableIdentifier: Swift.AnyHashable {
    get
  }
}
public struct CPImageProcessingContext {
  public let request: CPCoreKit.CPImageRequest
  public let isFinal: Swift.Bool
  public let scanNumber: Swift.Int?
}
public enum CPImageProcessor {
}
extension CPCoreKit.CPImageProcessor {
  public enum Unit : Swift.CustomStringConvertible {
    case points
    case pixels
    public var description: Swift.String {
      get
    }
    public static func == (a: CPCoreKit.CPImageProcessor.Unit, b: CPCoreKit.CPImageProcessor.Unit) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Resize : CPCoreKit.CPImageProcessing, Swift.Hashable, Swift.CustomStringConvertible {
    public enum ContentMode : Swift.CustomStringConvertible {
      case aspectFill
      case aspectFit
      public var description: Swift.String {
        get
      }
      public static func == (a: CPCoreKit.CPImageProcessor.Resize.ContentMode, b: CPCoreKit.CPImageProcessor.Resize.ContentMode) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(size: CoreGraphics.CGSize, unit: CPCoreKit.CPImageProcessor.Unit = .points, contentMode: CPCoreKit.CPImageProcessor.Resize.ContentMode = .aspectFill, crop: Swift.Bool = false, upscale: Swift.Bool = false)
    public func process(image: CPCoreKit.CPImage, context: CPCoreKit.CPImageProcessingContext?) -> CPCoreKit.CPImage?
    public var identifier: Swift.String {
      get
    }
    public var hashableIdentifier: Swift.AnyHashable {
      get
    }
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CPCoreKit.CPImageProcessor.Resize, b: CPCoreKit.CPImageProcessor.Resize) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension CPCoreKit.CPImageProcessor {
  public struct Circle : CPCoreKit.CPImageProcessing, Swift.Hashable, Swift.CustomStringConvertible {
    public init()
    public func process(image: CPCoreKit.CPImage, context: CPCoreKit.CPImageProcessingContext?) -> CPCoreKit.CPImage?
    public var identifier: Swift.String {
      get
    }
    public var hashableIdentifier: Swift.AnyHashable {
      get
    }
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CPCoreKit.CPImageProcessor.Circle, b: CPCoreKit.CPImageProcessor.Circle) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension CPCoreKit.CPImageProcessor {
  public struct RoundedCorners : CPCoreKit.CPImageProcessing, Swift.Hashable, Swift.CustomStringConvertible {
    public struct Border : Swift.Hashable {
      public init(color: UIKit.UIColor, width: CoreGraphics.CGFloat = 1)
      public var description: Swift.String {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: CPCoreKit.CPImageProcessor.RoundedCorners.Border, b: CPCoreKit.CPImageProcessor.RoundedCorners.Border) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(radius: CoreGraphics.CGFloat, unit: CPCoreKit.CPImageProcessor.Unit = .points, border: CPCoreKit.CPImageProcessor.RoundedCorners.Border? = nil)
    public func process(image: CPCoreKit.CPImage, context: CPCoreKit.CPImageProcessingContext?) -> CPCoreKit.CPImage?
    public var identifier: Swift.String {
      get
    }
    public var hashableIdentifier: Swift.AnyHashable {
      get
    }
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CPCoreKit.CPImageProcessor.RoundedCorners, b: CPCoreKit.CPImageProcessor.RoundedCorners) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension CPCoreKit.CPImageProcessor {
  public struct CoreImageFilter : CPCoreKit.CPImageProcessing, Swift.CustomStringConvertible {
    public let identifier: Swift.String
    public init(name: Swift.String, parameters: [Swift.String : Any], identifier: Swift.String)
    public init(name: Swift.String)
    public func process(image: CPCoreKit.CPImage, context: CPCoreKit.CPImageProcessingContext?) -> CPCoreKit.CPImage?
    public static var context: CoreImage.CIContext
    public static func apply(filter: CoreImage.CIFilter?, to image: UIKit.UIImage) -> UIKit.UIImage?
    public var description: Swift.String {
      get
    }
  }
}
extension CPCoreKit.CPImageProcessor {
  public struct GaussianBlur : CPCoreKit.CPImageProcessing, Swift.Hashable, Swift.CustomStringConvertible {
    public init(radius: Swift.Int = 8)
    public func process(image: CPCoreKit.CPImage, context: CPCoreKit.CPImageProcessingContext?) -> CPCoreKit.CPImage?
    public var identifier: Swift.String {
      get
    }
    public var hashableIdentifier: Swift.AnyHashable {
      get
    }
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CPCoreKit.CPImageProcessor.GaussianBlur, b: CPCoreKit.CPImageProcessor.GaussianBlur) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension CPCoreKit.CPImageProcessor {
  public struct Composition : CPCoreKit.CPImageProcessing, Swift.Hashable, Swift.CustomStringConvertible {
    public init(_ processors: [CPCoreKit.CPImageProcessing])
    public func process(image: CPCoreKit.CPImage, context: CPCoreKit.CPImageProcessingContext?) -> CPCoreKit.CPImage?
    public var identifier: Swift.String {
      get
    }
    public var hashableIdentifier: Swift.AnyHashable {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: CPCoreKit.CPImageProcessor.Composition, rhs: CPCoreKit.CPImageProcessor.Composition) -> Swift.Bool
    public var description: Swift.String {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension CPCoreKit.CPImageProcessor {
  public struct Anonymous : CPCoreKit.CPImageProcessing, Swift.CustomStringConvertible {
    public let identifier: Swift.String
    public init(id: Swift.String, _ closure: @escaping (CPCoreKit.CPImage) -> CPCoreKit.CPImage?)
    public func process(image: CPCoreKit.CPImage, context: CPCoreKit.CPImageProcessingContext?) -> CPCoreKit.CPImage?
    public var description: Swift.String {
      get
    }
  }
}
extension CoreGraphics.CGSize : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum Context {
  case main
  case userInteractive
  case userInitiated
  case utility
  case background
  case custom(queue: Dispatch.DispatchQueue)
  public var queue: Dispatch.DispatchQueue {
    get
  }
}
extension Swift.String {
  public func stringByAddingPercentEncodingToData() -> Swift.String
}
extension CoreGraphics.CGFloat {
  public var abs: CoreGraphics.CGFloat {
    get
  }
  public var ceil: CoreGraphics.CGFloat {
    get
  }
  public var degreesToRadians: CoreGraphics.CGFloat {
    get
  }
  public var floor: CoreGraphics.CGFloat {
    get
  }
  public var isPositive: Swift.Bool {
    get
  }
  public var isNegative: Swift.Bool {
    get
  }
  public var int: Swift.Int {
    get
  }
  public var float: Swift.Float {
    get
  }
  public var double: Swift.Double {
    get
  }
  public var radiansToDegrees: CoreGraphics.CGFloat {
    get
  }
}
extension CoreGraphics.CGVector {
  public var angle: CoreGraphics.CGFloat {
    get
  }
  public var magnitude: CoreGraphics.CGFloat {
    get
  }
}
extension CoreGraphics.CGVector {
  public init(angle: CoreGraphics.CGFloat, magnitude: CoreGraphics.CGFloat)
}
extension CoreGraphics.CGVector {
  public static func * (vector: CoreGraphics.CGVector, scalar: CoreGraphics.CGFloat) -> CoreGraphics.CGVector
  public static func * (scalar: CoreGraphics.CGFloat, vector: CoreGraphics.CGVector) -> CoreGraphics.CGVector
  public static func *= (vector: inout CoreGraphics.CGVector, scalar: CoreGraphics.CGFloat)
  prefix public static func - (vector: CoreGraphics.CGVector) -> CoreGraphics.CGVector
}
public enum CPSwiftyJSONError : Swift.Int, Swift.Error {
  case unsupportedType
  case indexOutOfBounds
  case elementTooDeep
  case wrongType
  case notExist
  case invalidJSON
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension CPCoreKit.CPSwiftyJSONError : Foundation.CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public enum CPType : Swift.Int {
  case number
  case string
  case bool
  case array
  case dictionary
  case null
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct CPJSON {
  public init(data: Foundation.Data, options opt: Foundation.JSONSerialization.ReadingOptions = []) throws
  public init(_ object: Any)
  public init(parseJSON jsonString: Swift.String)
  public mutating func merge(with other: CPCoreKit.CPJSON) throws
  public func merged(with other: CPCoreKit.CPJSON) throws -> CPCoreKit.CPJSON
  public var type: CPCoreKit.CPType {
    get
  }
  public var error: CPCoreKit.CPSwiftyJSONError? {
    get
  }
  public var object: Any {
    get
    set
  }
  @available(*, unavailable, renamed: "null")
  public static var nullJSON: CPCoreKit.CPJSON {
    get
  }
  public static var null: CPCoreKit.CPJSON {
    get
  }
}
public enum Index<T> : Swift.Comparable {
  case array(Swift.Int)
  case dictionary(Swift.DictionaryIndex<Swift.String, T>)
  case null
  public static func == (lhs: CPCoreKit.Index<T>, rhs: CPCoreKit.Index<T>) -> Swift.Bool
  public static func < (lhs: CPCoreKit.Index<T>, rhs: CPCoreKit.Index<T>) -> Swift.Bool
}
public typealias CPJSONIndex = CPCoreKit.Index<CPCoreKit.CPJSON>
public typealias CPJSONRawIndex = CPCoreKit.Index<Any>
extension CPCoreKit.CPJSON : Swift.Collection {
  public typealias Index = CPCoreKit.CPJSONRawIndex
  public var startIndex: CPCoreKit.CPJSON.Index {
    get
  }
  public var endIndex: CPCoreKit.CPJSON.Index {
    get
  }
  public func index(after i: CPCoreKit.CPJSON.Index) -> CPCoreKit.CPJSON.Index
  public subscript(position: CPCoreKit.CPJSON.Index) -> (Swift.String, CPCoreKit.CPJSON) {
    get
  }
  public typealias Element = (Swift.String, CPCoreKit.CPJSON)
  public typealias Indices = Swift.DefaultIndices<CPCoreKit.CPJSON>
  public typealias Iterator = Swift.IndexingIterator<CPCoreKit.CPJSON>
  public typealias SubSequence = Swift.Slice<CPCoreKit.CPJSON>
}
public enum CPJSONKey {
  case index(Swift.Int)
  case key(Swift.String)
}
public protocol CPJSONSubscriptType {
  var jsonKey: CPCoreKit.CPJSONKey { get }
}
extension Swift.Int : CPCoreKit.CPJSONSubscriptType {
  public var jsonKey: CPCoreKit.CPJSONKey {
    get
  }
}
extension Swift.String : CPCoreKit.CPJSONSubscriptType {
  public var jsonKey: CPCoreKit.CPJSONKey {
    get
  }
}
extension CPCoreKit.CPJSON {
  public subscript(path: [CPCoreKit.CPJSONSubscriptType]) -> CPCoreKit.CPJSON {
    get
    set
  }
  public subscript(path: CPCoreKit.CPJSONSubscriptType...) -> CPCoreKit.CPJSON {
    get
    set
  }
}
extension CPCoreKit.CPJSON : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: Swift.StringLiteralType)
  public init(unicodeScalarLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension CPCoreKit.CPJSON : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
extension CPCoreKit.CPJSON : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension CPCoreKit.CPJSON : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.FloatLiteralType)
  public typealias FloatLiteralType = Swift.FloatLiteralType
}
extension CPCoreKit.CPJSON : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Any)...)
  public typealias Key = Swift.String
  public typealias Value = Any
}
extension CPCoreKit.CPJSON : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension CPCoreKit.CPJSON : Swift.RawRepresentable {
  public init?(rawValue: Any)
  public var rawValue: Any {
    get
  }
  public func rawData(options opt: Foundation.JSONSerialization.WritingOptions = JSONSerialization.WritingOptions(rawValue: 0)) throws -> Foundation.Data
  public func rawString(_ encoding: Swift.String.Encoding = .utf8, options opt: Foundation.JSONSerialization.WritingOptions = .prettyPrinted) -> Swift.String?
  public func rawString(_ options: [CPCoreKit.writingOptionsKeys : Any]) -> Swift.String?
  public typealias RawValue = Any
}
extension CPCoreKit.CPJSON : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension CPCoreKit.CPJSON {
  public var array: [CPCoreKit.CPJSON]? {
    get
  }
  public var arrayValue: [CPCoreKit.CPJSON] {
    get
  }
  public var arrayObject: [Any]? {
    get
    set
  }
}
extension CPCoreKit.CPJSON {
  public var dictionary: [Swift.String : CPCoreKit.CPJSON]? {
    get
  }
  public var dictionaryValue: [Swift.String : CPCoreKit.CPJSON] {
    get
  }
  public var dictionaryObject: [Swift.String : Any]? {
    get
    set
  }
}
extension CPCoreKit.CPJSON {
  public var bool: Swift.Bool? {
    get
    set
  }
  public var boolValue: Swift.Bool {
    get
    set
  }
}
extension CPCoreKit.CPJSON {
  public var string: Swift.String? {
    get
    set
  }
  public var stringValue: Swift.String {
    get
    set
  }
}
extension CPCoreKit.CPJSON {
  public var number: Foundation.NSNumber? {
    get
    set
  }
  public var numberValue: Foundation.NSNumber {
    get
    set
  }
}
extension CPCoreKit.CPJSON {
  public var null: Foundation.NSNull? {
    get
    set
  }
  public func exists() -> Swift.Bool
}
extension CPCoreKit.CPJSON {
  public var url: Foundation.URL? {
    get
    set
  }
}
extension CPCoreKit.CPJSON {
  public var double: Swift.Double? {
    get
    set
  }
  public var doubleValue: Swift.Double {
    get
    set
  }
  public var float: Swift.Float? {
    get
    set
  }
  public var floatValue: Swift.Float {
    get
    set
  }
  public var int: Swift.Int? {
    get
    set
  }
  public var intValue: Swift.Int {
    get
    set
  }
  public var uInt: Swift.UInt? {
    get
    set
  }
  public var uIntValue: Swift.UInt {
    get
    set
  }
  public var int8: Swift.Int8? {
    get
    set
  }
  public var int8Value: Swift.Int8 {
    get
    set
  }
  public var uInt8: Swift.UInt8? {
    get
    set
  }
  public var uInt8Value: Swift.UInt8 {
    get
    set
  }
  public var int16: Swift.Int16? {
    get
    set
  }
  public var int16Value: Swift.Int16 {
    get
    set
  }
  public var uInt16: Swift.UInt16? {
    get
    set
  }
  public var uInt16Value: Swift.UInt16 {
    get
    set
  }
  public var int32: Swift.Int32? {
    get
    set
  }
  public var int32Value: Swift.Int32 {
    get
    set
  }
  public var uInt32: Swift.UInt32? {
    get
    set
  }
  public var uInt32Value: Swift.UInt32 {
    get
    set
  }
  public var int64: Swift.Int64? {
    get
    set
  }
  public var int64Value: Swift.Int64 {
    get
    set
  }
  public var uInt64: Swift.UInt64? {
    get
    set
  }
  public var uInt64Value: Swift.UInt64 {
    get
    set
  }
}
extension CPCoreKit.CPJSON : Swift.Comparable {
}
public func == (lhs: CPCoreKit.CPJSON, rhs: CPCoreKit.CPJSON) -> Swift.Bool
public func <= (lhs: CPCoreKit.CPJSON, rhs: CPCoreKit.CPJSON) -> Swift.Bool
public func >= (lhs: CPCoreKit.CPJSON, rhs: CPCoreKit.CPJSON) -> Swift.Bool
public func > (lhs: CPCoreKit.CPJSON, rhs: CPCoreKit.CPJSON) -> Swift.Bool
public func < (lhs: CPCoreKit.CPJSON, rhs: CPCoreKit.CPJSON) -> Swift.Bool
public enum writingOptionsKeys {
  case jsonSerialization
  case castNilToNSNull
  case maxObjextDepth
  case encoding
  public static func == (a: CPCoreKit.writingOptionsKeys, b: CPCoreKit.writingOptionsKeys) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension CPCoreKit.CPJSON : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public var isVisible: Swift.Bool {
    get
  }
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public func addNotificationObserver(name: Foundation.Notification.Name, selector: ObjectiveC.Selector)
  @_Concurrency.MainActor(unsafe) public func removeNotificationObserver(name: Foundation.Notification.Name)
  @_Concurrency.MainActor(unsafe) public func removeNotificationsObserver()
  @discardableResult
  @_Concurrency.MainActor(unsafe) public func showAlert(title: Swift.String?, message: Swift.String?, buttonTitles: [Swift.String]? = nil, highlightedButtonIndex: Swift.Int? = nil, completion: ((Swift.Int) -> Swift.Void)? = nil) -> UIKit.UIAlertController
  @_Concurrency.MainActor(unsafe) public func addChildViewController(_ child: UIKit.UIViewController, toContainerView containerView: UIKit.UIView)
  @_Concurrency.MainActor(unsafe) public func removeViewAndControllerFromParentViewController()
  @_Concurrency.MainActor(unsafe) public func presentPopover(_ popoverContent: UIKit.UIViewController, sourcePoint: CoreGraphics.CGPoint, size: CoreGraphics.CGSize? = nil, delegate: UIKit.UIPopoverPresentationControllerDelegate? = nil, animated: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
}
extension UIKit.UIFont {
  public var bold: UIKit.UIFont {
    get
  }
  public var italic: UIKit.UIFont {
    get
  }
  public var monospaced: UIKit.UIFont {
    get
  }
}
extension CPCoreKit.Promise {
  @discardableResult
  public func always(in context: CPCoreKit.Context? = nil, body: @escaping () throws -> Swift.Void) -> CPCoreKit.Promise<Value>
}
extension Foundation.NSAttributedString {
  public var bolded: Foundation.NSAttributedString {
    get
  }
  public var underlined: Foundation.NSAttributedString {
    get
  }
  public var italicized: Foundation.NSAttributedString {
    get
  }
  public var struckthrough: Foundation.NSAttributedString {
    get
  }
  public var attributes: [Foundation.NSAttributedString.Key : Any] {
    get
  }
}
extension Foundation.NSAttributedString {
  public func colored(with color: CPCoreKit.Color) -> Foundation.NSAttributedString
  public func applying(attributes: [Foundation.NSAttributedString.Key : Any], toRangesMatching pattern: Swift.String, options: Foundation.NSRegularExpression.Options = []) -> Foundation.NSAttributedString
  public func applying<T>(attributes: [Foundation.NSAttributedString.Key : Any], toOccurrencesOf target: T) -> Foundation.NSAttributedString where T : Swift.StringProtocol
}
extension Foundation.NSAttributedString {
  public static func += (lhs: inout Foundation.NSAttributedString, rhs: Foundation.NSAttributedString)
  public static func + (lhs: Foundation.NSAttributedString, rhs: Foundation.NSAttributedString) -> Foundation.NSAttributedString
  public static func += (lhs: inout Foundation.NSAttributedString, rhs: Swift.String)
  public static func + (lhs: Foundation.NSAttributedString, rhs: Swift.String) -> Foundation.NSAttributedString
}
public class CPThrottler {
  public init(minimumDelay: Foundation.TimeInterval, queue: Dispatch.DispatchQueue = DispatchQueue.main)
  public func throttle(_ block: @escaping () -> Swift.Void)
  @objc deinit
}
public struct Network {
  public static func available() -> Swift.Bool
}
extension UIKit.UISegmentedControl {
  @_Concurrency.MainActor(unsafe) public var segmentTitles: [Swift.String] {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var segmentImages: [UIKit.UIImage] {
    get
    set
  }
}
public func all<L>(_ promises: CPCoreKit.Promise<L>..., concurrency: Swift.UInt = UInt.max) -> CPCoreKit.Promise<[L]>
public func all<L, S>(_ promises: S, concurrency: Swift.UInt = UInt.max) -> CPCoreKit.Promise<[L]> where S : Swift.Sequence, S.Element == CPCoreKit.Promise<L>
public enum PromiseError : Swift.Error {
  case timeout
  case rejected
  case invalidInput
  case invalidContext
  case attemptsFailed
  public static func == (a: CPCoreKit.PromiseError, b: CPCoreKit.PromiseError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol InvalidatableProtocol {
  var isCancelled: Swift.Bool { get }
}
open class InvalidationToken : CPCoreKit.InvalidatableProtocol {
  public var isCancelled: Swift.Bool
  public func invalidate()
  public init()
  @objc deinit
}
public struct PromiseStatus {
  public let cancel: (() -> ())
  public var isCancelled: Swift.Bool {
    get
  }
}
public enum PasswordStrength {
  case veryWeak
  case weak
  case reasonable
  case strong
  case veryStrong
  public static func == (a: CPCoreKit.PasswordStrength, b: CPCoreKit.PasswordStrength) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Navajo {
  public static func strength(ofPassword password: Swift.String) -> CPCoreKit.PasswordStrength
  public static func localizedString(forStrength strength: CPCoreKit.PasswordStrength) -> Swift.String
  @objc deinit
}
public func cplog(_ block: () -> ())
public struct HTTPHeaders {
  public static func standardHeaders() -> [Swift.String : Swift.String]
  public static func formEncoded() -> [Swift.String : Swift.String]
  public static func formData(boundary: Swift.String) -> [Swift.String : Swift.String]
}
extension Swift.Sequence {
  public func all(matching condition: (Self.Element) throws -> Swift.Bool) rethrows -> Swift.Bool
  public func none(matching condition: (Self.Element) throws -> Swift.Bool) rethrows -> Swift.Bool
  public func any(matching condition: (Self.Element) throws -> Swift.Bool) rethrows -> Swift.Bool
  public func last(where condition: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Element?
  public func reject(where condition: (Self.Element) throws -> Swift.Bool) rethrows -> [Self.Element]
  public func count(where condition: (Self.Element) throws -> Swift.Bool) rethrows -> Swift.Int
  public func forEachReversed(_ body: (Self.Element) throws -> Swift.Void) rethrows
  public func forEach(where condition: (Self.Element) throws -> Swift.Bool, body: (Self.Element) throws -> Swift.Void) rethrows
  public func accumulate<U>(initial: U, next: (U, Self.Element) throws -> U) rethrows -> [U]
  public func filtered<T>(_ isIncluded: (Self.Element) throws -> Swift.Bool, map transform: (Self.Element) throws -> T) rethrows -> [T]
  public func single(where condition: ((Self.Element) throws -> Swift.Bool)) rethrows -> Self.Element?
  public func withoutDuplicates<T>(transform: (Self.Element) throws -> T) rethrows -> [Self.Element] where T : Swift.Hashable
  public func divided(by condition: (Self.Element) throws -> Swift.Bool) rethrows -> (matching: [Self.Element], nonMatching: [Self.Element])
  public func sorted<T>(by keyPath: Swift.KeyPath<Self.Element, T>, with compare: (T, T) -> Swift.Bool) -> [Self.Element]
  public func sorted<T>(by keyPath: Swift.KeyPath<Self.Element, T>) -> [Self.Element] where T : Swift.Comparable
  public func sorted<T, U>(by keyPath1: Swift.KeyPath<Self.Element, T>, and keyPath2: Swift.KeyPath<Self.Element, U>) -> [Self.Element] where T : Swift.Comparable, U : Swift.Comparable
  public func sorted<T, U, V>(by keyPath1: Swift.KeyPath<Self.Element, T>, and keyPath2: Swift.KeyPath<Self.Element, U>, and keyPath3: Swift.KeyPath<Self.Element, V>) -> [Self.Element] where T : Swift.Comparable, U : Swift.Comparable, V : Swift.Comparable
  public func sum<T>(for keyPath: Swift.KeyPath<Self.Element, T>) -> T where T : Swift.AdditiveArithmetic
  public func map<T>(by keyPath: Swift.KeyPath<Self.Element, T>) -> [T]
  public func compactMap<T>(by keyPath: Swift.KeyPath<Self.Element, T?>) -> [T]
  public func filter(by keyPath: Swift.KeyPath<Self.Element, Swift.Bool>) -> [Self.Element]
}
extension Swift.Sequence where Self.Element : Swift.Equatable {
  public func containsSequence(_ elements: [Self.Element]) -> Swift.Bool
}
extension Swift.Sequence where Self.Element : Swift.Hashable {
  public func containsDuplicates() -> Swift.Bool
  public func duplicates() -> [Self.Element]
}
extension Swift.Sequence where Self.Element : Swift.Numeric {
  public func sum() -> Self.Element
}
extension UIKit.UITextField {
  public enum TextType {
    case emailAddress
    case password
    case generic
    public static func == (a: UIKit.UITextField.TextType, b: UIKit.UITextField.TextType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension UIKit.UITextField {
  @_Concurrency.MainActor(unsafe) public var textType: UIKit.UITextField.TextType {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var isEmpty: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public var trimmedText: Swift.String? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var hasValidEmail: Swift.Bool {
    get
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var leftViewTintColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var rightViewTintColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
}
extension UIKit.UITextField {
  @_Concurrency.MainActor(unsafe) public func clear()
  @_Concurrency.MainActor(unsafe) public func setPlaceHolderTextColor(_ color: UIKit.UIColor)
  @_Concurrency.MainActor(unsafe) public func addPaddingLeft(_ padding: CoreGraphics.CGFloat)
  @_Concurrency.MainActor(unsafe) public func addPaddingLeftIcon(_ image: UIKit.UIImage, padding: CoreGraphics.CGFloat)
}
public enum RequiredCharacterRulePreset {
  case lowercaseCharacter
  case uppercaseCharacter
  case decimalDigitCharacter
  case symbolCharacter
  public static func == (a: CPCoreKit.RequiredCharacterRulePreset, b: CPCoreKit.RequiredCharacterRulePreset) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class RequiredCharacterRule : CPCoreKit.PasswordRule {
  public var requiredCharacterSet: Foundation.CharacterSet? {
    get
    set
  }
  public var preset: CPCoreKit.RequiredCharacterRulePreset? {
    get
    set
  }
  convenience public init(requiredCharacterSet: Foundation.CharacterSet)
  convenience public init(preset: CPCoreKit.RequiredCharacterRulePreset)
  public func evaluate(_ password: Swift.String) -> Swift.Bool
  public var localizedErrorDescription: Swift.String {
    get
  }
  @objc deinit
}
extension UIKit.UIImage {
  public var bytesSize: Swift.Int {
    get
  }
  public var kilobytesSize: Swift.Int {
    get
  }
  public var original: UIKit.UIImage {
    get
  }
  public var template: UIKit.UIImage {
    get
  }
}
extension UIKit.UIImage {
  public func compressed(quality: CoreGraphics.CGFloat = 0.5) -> UIKit.UIImage?
  public func compressedData(quality: CoreGraphics.CGFloat = 0.5) -> Foundation.Data?
  public func cropped(to rect: CoreGraphics.CGRect) -> UIKit.UIImage
  public func scaled(toHeight: CoreGraphics.CGFloat, opaque: Swift.Bool = false) -> UIKit.UIImage?
  public func scaled(toWidth: CoreGraphics.CGFloat, opaque: Swift.Bool = false) -> UIKit.UIImage?
  @available(iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public func rotated(by angle: Foundation.Measurement<Foundation.UnitAngle>) -> UIKit.UIImage?
  public func rotated(by radians: CoreGraphics.CGFloat) -> UIKit.UIImage?
  public func filled(withColor color: UIKit.UIColor) -> UIKit.UIImage
  public func tint(_ color: UIKit.UIColor, blendMode: CoreGraphics.CGBlendMode, alpha: CoreGraphics.CGFloat = 1.0) -> UIKit.UIImage
  public func withBackgroundColor(_ backgroundColor: UIKit.UIColor) -> UIKit.UIImage
  public func withRoundedCorners(radius: CoreGraphics.CGFloat? = nil) -> UIKit.UIImage?
  public func pngBase64String() -> Swift.String?
  public func jpegBase64String(compressionQuality: CoreGraphics.CGFloat) -> Swift.String?
}
extension UIKit.UIImage {
  convenience public init(color: UIKit.UIColor, size: CoreGraphics.CGSize)
  convenience public init?(base64String: Swift.String, scale: CoreGraphics.CGFloat = 1.0)
  convenience public init?(url: Foundation.URL, scale: CoreGraphics.CGFloat = 1.0) throws
}
extension UIKit.UITableView {
  @_Concurrency.MainActor(unsafe) public var indexPathForLastRow: Foundation.IndexPath? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var lastSection: Swift.Int? {
    get
  }
}
extension UIKit.UITableView {
  @_Concurrency.MainActor(unsafe) public func numberOfRows() -> Swift.Int
  @_Concurrency.MainActor(unsafe) public func indexPathForLastRow(inSection section: Swift.Int) -> Foundation.IndexPath?
  @_Concurrency.MainActor(unsafe) public func reloadData(_ completion: @escaping () -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func removeTableFooterView()
  @_Concurrency.MainActor(unsafe) public func removeTableHeaderView()
  @_Concurrency.MainActor(unsafe) public func scrollToBottom(animated: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func scrollToTop(animated: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func dequeueReusableCell<T>(withClass name: T.Type) -> T where T : UIKit.UITableViewCell
  @_Concurrency.MainActor(unsafe) public func dequeueReusableCell<T>(withClass name: T.Type, for indexPath: Foundation.IndexPath) -> T where T : UIKit.UITableViewCell
  @_Concurrency.MainActor(unsafe) public func dequeueReusableHeaderFooterView<T>(withClass name: T.Type) -> T where T : UIKit.UITableViewHeaderFooterView
  @_Concurrency.MainActor(unsafe) public func register<T>(nib: UIKit.UINib?, withHeaderFooterViewClass name: T.Type) where T : UIKit.UITableViewHeaderFooterView
  @_Concurrency.MainActor(unsafe) public func register<T>(headerFooterViewClassWith name: T.Type) where T : UIKit.UITableViewHeaderFooterView
  @_Concurrency.MainActor(unsafe) public func register<T>(cellWithClass name: T.Type) where T : UIKit.UITableViewCell
  @_Concurrency.MainActor(unsafe) public func register<T>(nib: UIKit.UINib?, withCellClass name: T.Type) where T : UIKit.UITableViewCell
  @_Concurrency.MainActor(unsafe) public func register<T>(nibWithCellClass name: T.Type, at bundleClass: Swift.AnyClass? = nil) where T : UIKit.UITableViewCell
  @_Concurrency.MainActor(unsafe) public func isValidIndexPath(_ indexPath: Foundation.IndexPath) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) public func safeScrollToRow(at indexPath: Foundation.IndexPath, at scrollPosition: UIKit.UITableView.ScrollPosition, animated: Swift.Bool)
}
extension StoreKit.SKProduct {
  public var localizedPrice: Swift.String? {
    get
  }
}
extension Foundation.NSRegularExpression {
  public func enumerateMatches(in string: Swift.String, options: Foundation.NSRegularExpression.MatchingOptions = [], range: Swift.Range<Swift.String.Index>, using block: (_ result: Foundation.NSTextCheckingResult?, _ flags: Foundation.NSRegularExpression.MatchingFlags, _ stop: inout Swift.Bool) -> Swift.Void)
  public func matches(in string: Swift.String, options: Foundation.NSRegularExpression.MatchingOptions = [], range: Swift.Range<Swift.String.Index>) -> [Foundation.NSTextCheckingResult]
  public func numberOfMatches(in string: Swift.String, options: Foundation.NSRegularExpression.MatchingOptions = [], range: Swift.Range<Swift.String.Index>) -> Swift.Int
  public func firstMatch(in string: Swift.String, options: Foundation.NSRegularExpression.MatchingOptions = [], range: Swift.Range<Swift.String.Index>) -> Foundation.NSTextCheckingResult?
  public func rangeOfFirstMatch(in string: Swift.String, options: Foundation.NSRegularExpression.MatchingOptions = [], range: Swift.Range<Swift.String.Index>) -> Swift.Range<Swift.String.Index>?
  public func stringByReplacingMatches(in string: Swift.String, options: Foundation.NSRegularExpression.MatchingOptions = [], range: Swift.Range<Swift.String.Index>, withTemplate templ: Swift.String) -> Swift.String
  @discardableResult
  public func replaceMatches(in string: inout Swift.String, options: Foundation.NSRegularExpression.MatchingOptions = [], range: Swift.Range<Swift.String.Index>, withTemplate templ: Swift.String) -> Swift.Int
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) final public class SwitchCameraButton : UIKit.UIButton {
  @_Concurrency.MainActor(unsafe) @objc override final public func draw(_ rect: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension UIKit.UILayoutPriority : Swift.ExpressibleByFloatLiteral, Swift.ExpressibleByIntegerLiteral {
  public init(floatLiteral value: Swift.Float)
  public init(integerLiteral value: Swift.Int)
  public typealias FloatLiteralType = Swift.Float
  public typealias IntegerLiteralType = Swift.Int
}
public enum CPHTTPFile {
  case url(Foundation.URL, Swift.String?)
  case data(Swift.String, Foundation.Data, Swift.String?)
  case text(Swift.String, Swift.String, Swift.String?)
}
public enum CPHTTPMethod : Swift.String {
  case delete
  case get
  case head
  case options
  case patch
  case post
  case put
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol CPURLComponentsConvertible {
  var urlComponents: Foundation.URLComponents? { get }
}
extension Swift.String : CPCoreKit.CPURLComponentsConvertible {
  public var urlComponents: Foundation.URLComponents? {
    get
  }
}
extension Foundation.URL : CPCoreKit.CPURLComponentsConvertible {
  public var urlComponents: Foundation.URLComponents? {
    get
  }
}
@objc final public class CPHTTPResult : ObjectiveC.NSObject {
  final public var content: Foundation.Data?
  final public var response: Foundation.URLResponse?
  final public var error: Swift.Error?
  final public var request: Foundation.URLRequest? {
    get
  }
  final public var task: Foundation.URLSessionTask?
  final public var encoding: Swift.String.Encoding
  final public var JSONReadingOptions: Foundation.JSONSerialization.ReadingOptions
  final public var reason: Swift.String {
    get
  }
  final public var isRedirect: Swift.Bool {
    get
  }
  final public var isPermanentRedirect: Swift.Bool {
    get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  public init(data: Foundation.Data?, response: Foundation.URLResponse?, error: Swift.Error?, task: Foundation.URLSessionTask?)
  final public var json: Any? {
    get
  }
  final public var statusCode: Swift.Int? {
    get
  }
  final public var text: Swift.String? {
    get
  }
  final public var headers: CPCoreKit.CPCaseInsensitiveDictionary<Swift.String, Swift.String> {
    get
    set
  }
  final public var cookies: [Swift.String : Foundation.HTTPCookie] {
    get
    set
  }
  final public var ok: Swift.Bool {
    get
  }
  final public var url: Foundation.URL? {
    get
  }
  final public var links: [Swift.String : [Swift.String : Swift.String]] {
    get
    set
  }
  final public func cancel()
  @objc deinit
}
public struct CPCaseInsensitiveDictionary<Key, Value> : Swift.Collection, Swift.ExpressibleByDictionaryLiteral where Key : Swift.Hashable {
  public typealias Element = (key: Key, value: Value)
  public typealias Index = Swift.DictionaryIndex<Key, Value>
  public var startIndex: CPCoreKit.CPCaseInsensitiveDictionary<Key, Value>.Index {
    get
  }
  public var endIndex: CPCoreKit.CPCaseInsensitiveDictionary<Key, Value>.Index {
    get
  }
  public func index(after: CPCoreKit.CPCaseInsensitiveDictionary<Key, Value>.Index) -> CPCoreKit.CPCaseInsensitiveDictionary<Key, Value>.Index
  public var count: Swift.Int {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public init(dictionaryLiteral elements: (Key, Value)...)
  public init(dictionary: [Key : Value])
  public subscript(position: CPCoreKit.CPCaseInsensitiveDictionary<Key, Value>.Index) -> CPCoreKit.CPCaseInsensitiveDictionary<Key, Value>.Element {
    get
  }
  public subscript(key: Key) -> Value? {
    get
    set(newValue)
  }
  public func makeIterator() -> Swift.DictionaryIterator<Key, Value>
  public var keys: Swift.Dictionary<Key, Value>.Keys {
    get
  }
  public var values: Swift.Dictionary<Key, Value>.Values {
    get
  }
  public typealias Indices = Swift.DefaultIndices<CPCoreKit.CPCaseInsensitiveDictionary<Key, Value>>
  public typealias Iterator = Swift.DictionaryIterator<Key, Value>
  public typealias SubSequence = Swift.Slice<CPCoreKit.CPCaseInsensitiveDictionary<Key, Value>>
}
public typealias CPCredentials = (username: Swift.String, password: Swift.String)
public typealias CPTaskProgressHandler = (CPCoreKit.CPHTTPProgress) -> Swift.Void
public struct CPJustSessionDefaults {
  public var JSONReadingOptions: Foundation.JSONSerialization.ReadingOptions
  public var JSONWritingOptions: Foundation.JSONSerialization.WritingOptions
  public var headers: [Swift.String : Swift.String]
  public var multipartBoundary: Swift.String
  public var credentialPersistence: Foundation.URLCredential.Persistence
  public var encoding: Swift.String.Encoding
  public var cachePolicy: Foundation.NSURLRequest.CachePolicy
  public init(JSONReadingOptions: Foundation.JSONSerialization.ReadingOptions = JSONSerialization.ReadingOptions(rawValue: 0), JSONWritingOptions: Foundation.JSONSerialization.WritingOptions = JSONSerialization.WritingOptions(rawValue: 0), headers: [Swift.String : Swift.String] = [:], multipartBoundary: Swift.String = "Ju5tH77P15Aw350m3", credentialPersistence: Foundation.URLCredential.Persistence = .forSession, encoding: Swift.String.Encoding = String.Encoding.utf8, cachePolicy: Foundation.NSURLRequest.CachePolicy = .reloadIgnoringLocalCacheData)
}
public struct CPHTTPProgress {
  public enum `Type` {
    case upload
    case download
    public static func == (a: CPCoreKit.CPHTTPProgress.`Type`, b: CPCoreKit.CPHTTPProgress.`Type`) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let type: CPCoreKit.CPHTTPProgress.`Type`
  public let bytesProcessed: Swift.Int64
  public let bytesExpectedToProcess: Swift.Int64
  public var chunk: Foundation.Data?
  public var percent: Swift.Float {
    get
  }
}
public protocol CPJustAdaptor {
  func request(_ method: CPCoreKit.CPHTTPMethod, url: CPCoreKit.CPURLComponentsConvertible, params: [Swift.String : Any], data: [Swift.String : Any], json: Any?, headers: [Swift.String : Swift.String], files: [Swift.String : CPCoreKit.CPHTTPFile], auth: CPCoreKit.CPCredentials?, cookies: [Swift.String : Swift.String], redirects: Swift.Bool, timeout: Swift.Double?, urlQuery: Swift.String?, requestBody: Foundation.Data?, asyncProgressHandler: CPCoreKit.CPTaskProgressHandler?, asyncCompletionHandler: ((CPCoreKit.CPHTTPResult) -> Swift.Void)?) -> CPCoreKit.CPHTTPResult
  init(session: Foundation.URLSession?, defaults: CPCoreKit.CPJustSessionDefaults?)
}
public struct CPJustOf<Adaptor> where Adaptor : CPCoreKit.CPJustAdaptor {
  public init(session: Foundation.URLSession? = nil, defaults: CPCoreKit.CPJustSessionDefaults? = nil)
}
extension CPCoreKit.CPJustOf {
  @discardableResult
  public func request(_ method: CPCoreKit.CPHTTPMethod, url: CPCoreKit.CPURLComponentsConvertible, params: [Swift.String : Any] = [:], data: [Swift.String : Any] = [:], json: Any? = nil, headers: [Swift.String : Swift.String] = [:], files: [Swift.String : CPCoreKit.CPHTTPFile] = [:], auth: (Swift.String, Swift.String)? = nil, cookies: [Swift.String : Swift.String] = [:], allowRedirects: Swift.Bool = true, timeout: Swift.Double? = nil, urlQuery: Swift.String? = nil, requestBody: Foundation.Data? = nil, asyncProgressHandler: (CPCoreKit.CPTaskProgressHandler)? = nil, asyncCompletionHandler: ((CPCoreKit.CPHTTPResult) -> Swift.Void)? = nil) -> CPCoreKit.CPHTTPResult
  @discardableResult
  public func delete(_ url: CPCoreKit.CPURLComponentsConvertible, params: [Swift.String : Any] = [:], data: [Swift.String : Any] = [:], json: Any? = nil, headers: [Swift.String : Swift.String] = [:], files: [Swift.String : CPCoreKit.CPHTTPFile] = [:], auth: (Swift.String, Swift.String)? = nil, cookies: [Swift.String : Swift.String] = [:], allowRedirects: Swift.Bool = true, timeout: Swift.Double? = nil, urlQuery: Swift.String? = nil, requestBody: Foundation.Data? = nil, asyncProgressHandler: (CPCoreKit.CPTaskProgressHandler)? = nil, asyncCompletionHandler: ((CPCoreKit.CPHTTPResult) -> Swift.Void)? = nil) -> CPCoreKit.CPHTTPResult
  @discardableResult
  public func get(_ url: CPCoreKit.CPURLComponentsConvertible, params: [Swift.String : Any] = [:], data: [Swift.String : Any] = [:], json: Any? = nil, headers: [Swift.String : Swift.String] = [:], files: [Swift.String : CPCoreKit.CPHTTPFile] = [:], auth: (Swift.String, Swift.String)? = nil, cookies: [Swift.String : Swift.String] = [:], allowRedirects: Swift.Bool = true, timeout: Swift.Double? = nil, urlQuery: Swift.String? = nil, requestBody: Foundation.Data? = nil, asyncProgressHandler: (CPCoreKit.CPTaskProgressHandler)? = nil, asyncCompletionHandler: ((CPCoreKit.CPHTTPResult) -> Swift.Void)? = nil) -> CPCoreKit.CPHTTPResult
  @discardableResult
  public func head(_ url: CPCoreKit.CPURLComponentsConvertible, params: [Swift.String : Any] = [:], data: [Swift.String : Any] = [:], json: Any? = nil, headers: [Swift.String : Swift.String] = [:], files: [Swift.String : CPCoreKit.CPHTTPFile] = [:], auth: (Swift.String, Swift.String)? = nil, cookies: [Swift.String : Swift.String] = [:], allowRedirects: Swift.Bool = true, timeout: Swift.Double? = nil, urlQuery: Swift.String? = nil, requestBody: Foundation.Data? = nil, asyncProgressHandler: (CPCoreKit.CPTaskProgressHandler)? = nil, asyncCompletionHandler: ((CPCoreKit.CPHTTPResult) -> Swift.Void)? = nil) -> CPCoreKit.CPHTTPResult
  @discardableResult
  public func options(_ url: CPCoreKit.CPURLComponentsConvertible, params: [Swift.String : Any] = [:], data: [Swift.String : Any] = [:], json: Any? = nil, headers: [Swift.String : Swift.String] = [:], files: [Swift.String : CPCoreKit.CPHTTPFile] = [:], auth: (Swift.String, Swift.String)? = nil, cookies: [Swift.String : Swift.String] = [:], allowRedirects: Swift.Bool = true, timeout: Swift.Double? = nil, urlQuery: Swift.String? = nil, requestBody: Foundation.Data? = nil, asyncProgressHandler: (CPCoreKit.CPTaskProgressHandler)? = nil, asyncCompletionHandler: ((CPCoreKit.CPHTTPResult) -> Swift.Void)? = nil) -> CPCoreKit.CPHTTPResult
  @discardableResult
  public func patch(_ url: CPCoreKit.CPURLComponentsConvertible, params: [Swift.String : Any] = [:], data: [Swift.String : Any] = [:], json: Any? = nil, headers: [Swift.String : Swift.String] = [:], files: [Swift.String : CPCoreKit.CPHTTPFile] = [:], auth: (Swift.String, Swift.String)? = nil, cookies: [Swift.String : Swift.String] = [:], allowRedirects: Swift.Bool = true, timeout: Swift.Double? = nil, urlQuery: Swift.String? = nil, requestBody: Foundation.Data? = nil, asyncProgressHandler: (CPCoreKit.CPTaskProgressHandler)? = nil, asyncCompletionHandler: ((CPCoreKit.CPHTTPResult) -> Swift.Void)? = nil) -> CPCoreKit.CPHTTPResult
  @discardableResult
  public func post(_ url: CPCoreKit.CPURLComponentsConvertible, params: [Swift.String : Any] = [:], data: [Swift.String : Any] = [:], json: Any? = nil, headers: [Swift.String : Swift.String] = [:], files: [Swift.String : CPCoreKit.CPHTTPFile] = [:], auth: (Swift.String, Swift.String)? = nil, cookies: [Swift.String : Swift.String] = [:], allowRedirects: Swift.Bool = true, timeout: Swift.Double? = nil, urlQuery: Swift.String? = nil, requestBody: Foundation.Data? = nil, asyncProgressHandler: (CPCoreKit.CPTaskProgressHandler)? = nil, asyncCompletionHandler: ((CPCoreKit.CPHTTPResult) -> Swift.Void)? = nil) -> CPCoreKit.CPHTTPResult
  @discardableResult
  public func put(_ url: CPCoreKit.CPURLComponentsConvertible, params: [Swift.String : Any] = [:], data: [Swift.String : Any] = [:], json: Any? = nil, headers: [Swift.String : Swift.String] = [:], files: [Swift.String : CPCoreKit.CPHTTPFile] = [:], auth: (Swift.String, Swift.String)? = nil, cookies: [Swift.String : Swift.String] = [:], allowRedirects: Swift.Bool = true, timeout: Swift.Double? = nil, urlQuery: Swift.String? = nil, requestBody: Foundation.Data? = nil, asyncProgressHandler: (CPCoreKit.CPTaskProgressHandler)? = nil, asyncCompletionHandler: ((CPCoreKit.CPHTTPResult) -> Swift.Void)? = nil) -> CPCoreKit.CPHTTPResult
}
@objc final public class CPHTTP : ObjectiveC.NSObject, Foundation.URLSessionDelegate, CPCoreKit.CPJustAdaptor {
  public init(session: Foundation.URLSession? = nil, defaults: CPCoreKit.CPJustSessionDefaults? = nil)
  final public func synthesizeRequest(_ method: CPCoreKit.CPHTTPMethod, url: CPCoreKit.CPURLComponentsConvertible, params: [Swift.String : Any], data: [Swift.String : Any], json: Any?, headers: CPCoreKit.CPCaseInsensitiveDictionary<Swift.String, Swift.String>, files: [Swift.String : CPCoreKit.CPHTTPFile], auth: CPCoreKit.CPCredentials?, timeout: Swift.Double?, urlQuery: Swift.String?, requestBody: Foundation.Data?) -> Foundation.URLRequest?
  final public func request(_ method: CPCoreKit.CPHTTPMethod, url: CPCoreKit.CPURLComponentsConvertible, params: [Swift.String : Any], data: [Swift.String : Any], json: Any?, headers: [Swift.String : Swift.String], files: [Swift.String : CPCoreKit.CPHTTPFile], auth: CPCoreKit.CPCredentials?, cookies: [Swift.String : Swift.String], redirects: Swift.Bool, timeout: Swift.Double?, urlQuery: Swift.String?, requestBody: Foundation.Data?, asyncProgressHandler: CPCoreKit.CPTaskProgressHandler?, asyncCompletionHandler: ((CPCoreKit.CPHTTPResult) -> Swift.Void)?) -> CPCoreKit.CPHTTPResult
  @objc deinit
}
extension CPCoreKit.CPHTTP : Foundation.URLSessionTaskDelegate, Foundation.URLSessionDataDelegate {
  @objc final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  @objc final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
}
public let CPJust: CPCoreKit.CPJustOf<CPCoreKit.CPHTTP>
extension Foundation.NSPredicate {
  public var not: Foundation.NSCompoundPredicate {
    get
  }
}
extension Foundation.NSPredicate {
  public func and(_ predicate: Foundation.NSPredicate) -> Foundation.NSCompoundPredicate
  public func or(_ predicate: Foundation.NSPredicate) -> Foundation.NSCompoundPredicate
}
extension Foundation.NSPredicate {
  prefix public static func ! (rhs: Foundation.NSPredicate) -> Foundation.NSCompoundPredicate
  public static func + (lhs: Foundation.NSPredicate, rhs: Foundation.NSPredicate) -> Foundation.NSCompoundPredicate
  public static func | (lhs: Foundation.NSPredicate, rhs: Foundation.NSPredicate) -> Foundation.NSCompoundPredicate
  public static func - (lhs: Foundation.NSPredicate, rhs: Foundation.NSPredicate) -> Foundation.NSCompoundPredicate
}
public protocol QRCodeReaderDisplayable {
  var cameraView: UIKit.UIView { get }
  var cancelButton: UIKit.UIButton? { get }
  var switchCameraButton: UIKit.UIButton? { get }
  var toggleTorchButton: UIKit.UIButton? { get }
  var overlayView: UIKit.UIView? { get }
  func setNeedsUpdateOrientation()
  func setupComponents(with builder: CPCoreKit.QRCodeReaderViewControllerBuilder)
}
public struct QRCodeReaderContainer {
  public init<T>(displayable: T) where T : UIKit.UIView, T : CPCoreKit.QRCodeReaderDisplayable
}
extension Swift.RandomAccessCollection where Self.Element : Swift.Equatable {
  public func indices(of item: Self.Element) -> [Self.Index]
}
extension CoreGraphics.CGSize {
  public var aspectRatio: CoreGraphics.CGFloat {
    get
  }
  public var maxDimension: CoreGraphics.CGFloat {
    get
  }
  public var minDimension: CoreGraphics.CGFloat {
    get
  }
}
extension CoreGraphics.CGSize {
  public func aspectFit(to boundingSize: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  public func aspectFill(to boundingSize: CoreGraphics.CGSize) -> CoreGraphics.CGSize
}
extension CoreGraphics.CGSize {
  public static func + (lhs: CoreGraphics.CGSize, rhs: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  public static func += (lhs: inout CoreGraphics.CGSize, rhs: CoreGraphics.CGSize)
  public static func - (lhs: CoreGraphics.CGSize, rhs: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  public static func -= (lhs: inout CoreGraphics.CGSize, rhs: CoreGraphics.CGSize)
  public static func * (lhs: CoreGraphics.CGSize, rhs: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  public static func * (lhs: CoreGraphics.CGSize, scalar: CoreGraphics.CGFloat) -> CoreGraphics.CGSize
  public static func * (scalar: CoreGraphics.CGFloat, rhs: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  public static func *= (lhs: inout CoreGraphics.CGSize, rhs: CoreGraphics.CGSize)
  public static func *= (lhs: inout CoreGraphics.CGSize, scalar: CoreGraphics.CGFloat)
}
public protocol CPImageDecoding {
  func decode(data: Foundation.Data, isFinal: Swift.Bool) -> CPCoreKit.CPImage?
}
extension CPCoreKit.CPImageDecoding {
  public func decode(data: Foundation.Data) -> CPCoreKit.CPImage?
}
final public class CPImageDecoder : CPCoreKit.CPImageDecoding {
  public init()
  final public func decode(data: Foundation.Data, isFinal: Swift.Bool) -> CPCoreKit.CPImage?
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class CPImageDecoderRegistry {
  public static let shared: CPCoreKit.CPImageDecoderRegistry
  final public func decoder(for context: CPCoreKit.CPImageDecodingContext) -> CPCoreKit.CPImageDecoding
  final public func register(_ match: @escaping (CPCoreKit.CPImageDecodingContext) -> CPCoreKit.CPImageDecoding?)
  @objc deinit
}
public struct CPImageDecodingContext {
  public let request: CPCoreKit.CPImageRequest
  public let data: Foundation.Data
  public let urlResponse: Foundation.URLResponse?
}
extension UIKit.UIImage {
  public var animatedImageData: Foundation.Data? {
    get
    set
  }
}
extension Swift.StringProtocol {
  public func commonSuffix<T>(with aString: T, options: Swift.String.CompareOptions = []) -> Swift.String where T : Swift.StringProtocol
}
extension UIKit.UINavigationBar {
  @_Concurrency.MainActor(unsafe) public func setTitleFont(_ font: UIKit.UIFont, color: UIKit.UIColor = .black)
  @_Concurrency.MainActor(unsafe) public func makeTransparent(withTint tint: UIKit.UIColor = .white)
  @_Concurrency.MainActor(unsafe) public func setColors(background: UIKit.UIColor, text: UIKit.UIColor)
}
@_hasMissingDesignatedInitializers final public class CPKeyChain {
  @objc deinit
}
extension CPCoreKit.CPKeyChain {
  public static var deviceId: Swift.String {
    get
  }
}
public func reduce<A, I, S>(in context: CPCoreKit.Context? = nil, _ items: S, _ initial: I, _ transform: @escaping (I, A) throws -> CPCoreKit.Promise<I>) -> CPCoreKit.Promise<I> where A == S.Element, S : Swift.Sequence
extension Foundation.Calendar {
  public func numberOfDaysInMonth(for date: Foundation.Date) -> Swift.Int
}
extension CPCoreKit.Promise {
  @discardableResult
  public func cancelled(in context: CPCoreKit.Context? = nil, _ body: @escaping (() -> (()))) -> CPCoreKit.Promise<Swift.Void>
}
public protocol QRCodeReaderViewControllerDelegate : AnyObject {
  func reader(_ reader: CPCoreKit.QRCodeReaderViewController, didScanResult result: CPCoreKit.QRCodeReaderResult)
  func reader(_ reader: CPCoreKit.QRCodeReaderViewController, didSwitchCamera newCaptureDevice: AVFoundation.AVCaptureDeviceInput)
  func readerDidCancel(_ reader: CPCoreKit.QRCodeReaderViewController)
}
extension CPCoreKit.QRCodeReaderViewControllerDelegate {
  public func reader(_ reader: CPCoreKit.QRCodeReaderViewController, didSwitchCamera newCaptureDevice: AVFoundation.AVCaptureDeviceInput)
}
extension SceneKit.SCNCapsule {
  convenience public init(capDiameter: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat)
  convenience public init(capRadius: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, material: SceneKit.SCNMaterial)
  convenience public init(capDiameter: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, material: SceneKit.SCNMaterial)
  convenience public init(capRadius: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, color: CPCoreKit.Color)
  convenience public init(capDiameter: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, color: CPCoreKit.Color)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class ReaderOverlayView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override final public func draw(_ rect: CoreGraphics.CGRect)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) final public class ToggleTorchButton : UIKit.UIButton {
  @_Concurrency.MainActor(unsafe) @objc override final public func draw(_ rect: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class CPImageTask : Swift.Hashable, Swift.CustomStringConvertible {
  final public let taskId: Swift.Int
  final public let request: CPCoreKit.CPImageRequest
  public var priority: CPCoreKit.CPImageRequest.Priority {
    get
    set
  }
  public var completedUnitCount: Swift.Int64 {
    get
  }
  public var totalUnitCount: Swift.Int64 {
    get
  }
  public var progress: Foundation.Progress {
    get
  }
  public typealias Completion = (_ result: Swift.Result<CPCoreKit.CPImageResponse, CPCoreKit.CPImagePipeline.Error>) -> Swift.Void
  public typealias ProgressHandler = (_ intermediateResponse: CPCoreKit.CPImageResponse?, _ completedUnitCount: Swift.Int64, _ totalUnitCount: Swift.Int64) -> Swift.Void
  public func cancel()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: CPCoreKit.CPImageTask, rhs: CPCoreKit.CPImageTask) -> Swift.Bool
  public var description: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
final public class CPImageResponse {
  final public let image: CPCoreKit.CPImage
  final public let urlResponse: Foundation.URLResponse?
  final public let scanNumber: Swift.Int?
  public init(image: CPCoreKit.CPImage, urlResponse: Foundation.URLResponse? = nil, scanNumber: Swift.Int? = nil)
  @objc deinit
}
extension UIKit.UIDatePicker {
  @_Concurrency.MainActor(unsafe) public var textColor: UIKit.UIColor? {
    get
    set
  }
}
public typealias EdgeInsets = UIKit.UIEdgeInsets
extension UIKit.UIEdgeInsets {
  public var vertical: CoreGraphics.CGFloat {
    get
  }
  public var horizontal: CoreGraphics.CGFloat {
    get
  }
}
extension UIKit.UIEdgeInsets {
  public init(inset: CoreGraphics.CGFloat)
  public init(horizontal: CoreGraphics.CGFloat, vertical: CoreGraphics.CGFloat)
  public func insetBy(top: CoreGraphics.CGFloat) -> CPCoreKit.EdgeInsets
  public func insetBy(left: CoreGraphics.CGFloat) -> CPCoreKit.EdgeInsets
  public func insetBy(bottom: CoreGraphics.CGFloat) -> CPCoreKit.EdgeInsets
  public func insetBy(right: CoreGraphics.CGFloat) -> CPCoreKit.EdgeInsets
  public func insetBy(horizontal: CoreGraphics.CGFloat) -> CPCoreKit.EdgeInsets
  public func insetBy(vertical: CoreGraphics.CGFloat) -> CPCoreKit.EdgeInsets
}
extension UIKit.UIEdgeInsets {
  public static func + (lhs: CPCoreKit.EdgeInsets, rhs: CPCoreKit.EdgeInsets) -> CPCoreKit.EdgeInsets
  public static func += (lhs: inout CPCoreKit.EdgeInsets, rhs: CPCoreKit.EdgeInsets)
}
extension CPCoreKit.CPHTTPResult {
  final public func httpCode() -> Swift.Int
  final public func responseJSON() -> CPCoreKit.CPJSON?
  final public func hasValidHTTPCode() -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class LengthRule : CPCoreKit.PasswordRule {
  public var range: Foundation.NSRange?
  convenience public init(min: Swift.Int, max: Swift.Int)
  public func evaluate(_ password: Swift.String) -> Swift.Bool
  open var localizedErrorDescription: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DictionaryWordRule : CPCoreKit.PasswordRule {
  public func evaluate(_ password: Swift.String) -> Swift.Bool
  public var localizedErrorDescription: Swift.String {
    get
  }
  @objc deinit
}
extension UIKit.UIApplication {
  public enum Environment {
    case debug
    case testFlight
    case appStore
    public static func == (a: UIKit.UIApplication.Environment, b: UIKit.UIApplication.Environment) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) public var inferredEnvironment: UIKit.UIApplication.Environment {
    get
  }
  @_Concurrency.MainActor(unsafe) public var displayName: Swift.String? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var buildNumber: Swift.String? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var version: Swift.String? {
    get
  }
}
extension CPCoreKit.Promise {
  @discardableResult
  public func `catch`(in context: CPCoreKit.Context? = nil, _ body: @escaping ((Swift.Error) throws -> ())) -> CPCoreKit.Promise<Swift.Void>
}
extension Swift.Dictionary where Key == Swift.String {
  public func consoleDescription() -> Swift.String
  public func dataRepresentation() -> Foundation.Data?
  public func formBodyData() -> Foundation.Data?
  public func urlQuery() -> Swift.String?
  public func formDataString(boundary: Swift.String) -> Swift.String
}
extension Swift.Dictionary where Key == Swift.String, Value == Swift.String {
  public func queryString() -> Swift.String
}
extension Swift.Dictionary where Key == Swift.String, Value == Swift.Optional<Any> {
  public subscript(key: CPCoreKit.CPCodingKey) -> Any? {
    get
    set(newValue)
  }
}
extension Swift.Dictionary where Key == Swift.String, Value == Any {
  public mutating func add(key: CPCoreKit.CPCodingKey, value: Any)
}
public typealias CPImage = UIKit.UIImage
@objc public protocol CPImageDisplaying {
  @objc func nuke_display(image: CPCoreKit.CPImage?)
}
public typealias CPImageDisplayingView = UIKit.UIView & CPCoreKit.CPImageDisplaying
extension UIKit.UIImageView : CPCoreKit.CPImageDisplaying {
  @_Concurrency.MainActor(unsafe) @objc dynamic open func nuke_display(image: CPCoreKit.CPImage?)
}
@discardableResult
public func loadImage(with url: Foundation.URL, options: CPCoreKit.ImageLoadingOptions = ImageLoadingOptions.shared, into view: CPCoreKit.CPImageDisplayingView, progress: CPCoreKit.CPImageTask.ProgressHandler? = nil, completion: CPCoreKit.CPImageTask.Completion? = nil) -> CPCoreKit.CPImageTask?
@discardableResult
public func loadImage(with request: CPCoreKit.CPImageRequest, options: CPCoreKit.ImageLoadingOptions = ImageLoadingOptions.shared, into view: CPCoreKit.CPImageDisplayingView, progress: CPCoreKit.CPImageTask.ProgressHandler? = nil, completion: CPCoreKit.CPImageTask.Completion? = nil) -> CPCoreKit.CPImageTask?
public func cancelRequest(for view: CPCoreKit.CPImageDisplayingView)
public struct ImageLoadingOptions {
  public static var shared: CPCoreKit.ImageLoadingOptions
  public var placeholder: CPCoreKit.CPImage?
  public var failureImage: CPCoreKit.CPImage?
  public var transition: CPCoreKit.ImageLoadingOptions.Transition?
  public var failureImageTransition: CPCoreKit.ImageLoadingOptions.Transition?
  public var alwaysTransition: Swift.Bool
  public var isPrepareForReuseEnabled: Swift.Bool
  public var pipeline: CPCoreKit.CPImagePipeline?
  public var contentModes: CPCoreKit.ImageLoadingOptions.ContentModes?
  public struct ContentModes {
    public var success: UIKit.UIView.ContentMode
    public var failure: UIKit.UIView.ContentMode
    public var placeholder: UIKit.UIView.ContentMode
    public init(success: UIKit.UIView.ContentMode, failure: UIKit.UIView.ContentMode, placeholder: UIKit.UIView.ContentMode)
  }
  public init(placeholder: CPCoreKit.CPImage? = nil, transition: CPCoreKit.ImageLoadingOptions.Transition? = nil, failureImage: CPCoreKit.CPImage? = nil, failureImageTransition: CPCoreKit.ImageLoadingOptions.Transition? = nil, contentModes: CPCoreKit.ImageLoadingOptions.ContentModes? = nil)
  public struct Transition {
    public static func fadeIn(duration: Foundation.TimeInterval, options: UIKit.UIView.AnimationOptions = .allowUserInteraction) -> CPCoreKit.ImageLoadingOptions.Transition
    public static func custom(_ closure: @escaping (CPCoreKit.CPImageDisplayingView, CPCoreKit.CPImage) -> Swift.Void) -> CPCoreKit.ImageLoadingOptions.Transition
  }
  public init()
}
extension UIKit.UIActivity.ActivityType {
  public static let addToiCloudDrive: UIKit.UIActivity.ActivityType
  public static let postToWhatsApp: UIKit.UIActivity.ActivityType
  public static let postToLinkedIn: UIKit.UIActivity.ActivityType
  public static let postToXing: UIKit.UIActivity.ActivityType
}
extension Swift.Float {
  public var int: Swift.Int {
    get
  }
  public var double: Swift.Double {
    get
  }
  public var cgFloat: CoreGraphics.CGFloat {
    get
  }
}
extension CPCoreKit.CPJSON {
  public func stringify(prettyPrinted: Swift.Bool = false) -> Swift.String?
}
extension Swift.String {
  public func json() -> CPCoreKit.CPJSON?
}
precedencegroup PowerPrecedence {
  higherThan: MultiplicationPrecedence
}
infix operator ** : PowerPrecedence
prefix operator √
prefix public func √ (float: Swift.Float) -> Swift.Float
prefix public func √ (double: Swift.Double) -> Swift.Double
prefix public func √ (int: Swift.Int) -> Swift.Double
infix operator ± : DefaultPrecedence
prefix operator ±
prefix public func ± <T>(number: T) -> (T, T) where T : Swift.FloatingPoint
prefix public func ± (int: Swift.Int) -> (Swift.Int, Swift.Int)
extension CPCoreKit.Promise {
  @discardableResult
  public func then<N>(in context: CPCoreKit.Context? = nil, _ body: @escaping ((Value) throws -> N)) -> CPCoreKit.Promise<N>
  @discardableResult
  public func then<N>(in context: CPCoreKit.Context? = nil, _ body: @escaping ((Value) throws -> (CPCoreKit.Promise<N>))) -> CPCoreKit.Promise<N>
  @discardableResult
  public func then(in context: CPCoreKit.Context? = nil, _ body: @escaping ((Value) throws -> ())) -> CPCoreKit.Promise<Value>
}
extension Swift.Error {
  public func cpError() -> CPCoreKit.CPError
  public func isTokenExpired() -> Swift.Bool
}
extension Foundation.FileManager {
  public func jsonFromFile(atPath path: Swift.String, readingOptions: Foundation.JSONSerialization.ReadingOptions = .allowFragments) throws -> [Swift.String : Any]?
  public func jsonFromFile(withFilename filename: Swift.String, at bundleClass: Swift.AnyClass? = nil, readingOptions: Foundation.JSONSerialization.ReadingOptions = .allowFragments) throws -> [Swift.String : Any]?
  public func createTemporaryDirectory() throws -> Foundation.URL
}
public protocol CPImageEncoding {
  func encode(image: CPCoreKit.CPImage) -> Foundation.Data?
}
public struct CPImageEncoder : CPCoreKit.CPImageEncoding {
  public func encode(image: CPCoreKit.CPImage) -> Foundation.Data?
}
public struct CPImageEncodingContext {
  public let request: CPCoreKit.CPImageRequest
  public let image: CPCoreKit.CPImage
  public let urlResponse: Foundation.URLResponse?
}
extension SceneKit.SCNCylinder {
  convenience public init(diameter: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat)
  convenience public init(radius: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, material: SceneKit.SCNMaterial)
  convenience public init(diameter: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, material: SceneKit.SCNMaterial)
  convenience public init(radius: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, color: CPCoreKit.Color)
  convenience public init(diameter: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, color: CPCoreKit.Color)
}
public protocol PasswordRule {
  func evaluate(_ password: Swift.String) -> Swift.Bool
  var localizedErrorDescription: Swift.String { get }
}
public protocol CPTokenProtocol {
  var token: Swift.String { get }
}
public enum AuthenticationType {
  case user
  case none
  case tenant
  public static func == (a: CPCoreKit.AuthenticationType, b: CPCoreKit.AuthenticationType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ContentHeaderType {
  case json
  case form_urlencoded
  case form_data
  public static func == (a: CPCoreKit.ContentHeaderType, b: CPCoreKit.ContentHeaderType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum RequestAuthorizationType {
  case none
  case basic(username: Swift.String, password: Swift.String)
  case bearer(token: CPCoreKit.CPTokenProtocol)
  case token(token: CPCoreKit.CPTokenProtocol)
}
public typealias CPCompletion = (Swift.Result<CPCoreKit.CPJSON, CPCoreKit.CPError>) -> Swift.Void
final public class CPRequest {
  public static func basicAuthorization() -> CPCoreKit.RequestAuthorizationType
  public init()
  final public func executeRequest(method: CPCoreKit.CPHTTPMethod = .post, authentication: CPCoreKit.AuthenticationType, requestBody: [Swift.String : Any]? = nil, bodyAsQuery: Swift.Bool = false, requestEndpoint: CPCoreKit.CPRequestEndpoint, headerType: CPCoreKit.ContentHeaderType = .json, queryDictionary: [Swift.String : Any]? = nil, authorization: CPCoreKit.RequestAuthorizationType = .none, additionalHeaders: [Swift.String : Swift.String]? = nil, logTitle: Swift.String? = nil, completion: CPCoreKit.CPCompletion?)
  final public func executeRequest(method: CPCoreKit.CPHTTPMethod = .post, authentication: CPCoreKit.AuthenticationType, requestBody: [Swift.String : Any]? = nil, bodyAsQuery: Swift.Bool = false, requestEndpoint: CPCoreKit.CPRequestEndpoint, headerType: CPCoreKit.ContentHeaderType = .json, queryDictionary: [Swift.String : Any]? = nil, authorization: CPCoreKit.RequestAuthorizationType = .none, headers: [Swift.String : Swift.String], logTitle: Swift.String? = nil, completion: CPCoreKit.CPCompletion?)
  @objc deinit
}
public enum CPInvalidRequestSource : Swift.String {
  case JSON
  case String
  case Nil
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct CPInvalidRequest : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public let statusMessage: Swift.String
  public let statusCode: Swift.String
  public let tenantName: Swift.String
  public let type: CPCoreKit.CPInvalidRequestSource
  public let additionalStatusMessage: Swift.String
  public let additionalStatusCode: Swift.String
  public let httpCode: Swift.Int
  public var responseData: Foundation.Data? {
    get
  }
  public var rawError: Swift.Error? {
    get
  }
}
extension CPCoreKit.CPInvalidRequest {
  public init(json: CPCoreKit.CPJSON)
}
extension CPCoreKit.CPInvalidRequest {
  public init(fromResult result: CPCoreKit.CPHTTPResult)
}
public class Promise<Value> {
  public typealias Resolved = (Value) -> ()
  public typealias Rejector = (Swift.Error) -> ()
  public typealias Body = ((_ resolve: @escaping CPCoreKit.Promise<Value>.Resolved, _ reject: @escaping CPCoreKit.Promise<Value>.Rejector, _ promise: CPCoreKit.PromiseStatus) throws -> ())
  public var name: Swift.String?
  public var operation: CPCoreKit.PromiseStatus {
    get
    set
  }
  public var result: Value? {
    get
  }
  public var error: Swift.Error? {
    get
  }
  public var isPending: Swift.Bool {
    get
  }
  public init(resolved value: Value)
  public init()
  public init(rejected error: Swift.Error)
  public init(in context: CPCoreKit.Context? = nil, token: CPCoreKit.InvalidationToken? = nil, _ body: @escaping CPCoreKit.Promise<Value>.Body)
  @objc deinit
  public func resolve(_ value: Value)
  public func reject(_ error: Swift.Error)
  public func cancel()
  public var isCancelled: Swift.Bool {
    get
  }
  public var void: CPCoreKit.Promise<Swift.Void> {
    get
  }
}
extension UIKit.UIStoryboard {
  @_Concurrency.MainActor(unsafe) public static var main: UIKit.UIStoryboard? {
    get
  }
  @_Concurrency.MainActor(unsafe) public func instantiateViewController<T>(withClass name: T.Type) -> T? where T : UIKit.UIViewController
}
extension CPCoreKit.Promise {
  public func `defer`(in context: CPCoreKit.Context? = nil, _ seconds: Foundation.TimeInterval) -> CPCoreKit.Promise<Value>
}
extension Dispatch.DispatchQueue {
  public static var isMainQueue: Swift.Bool {
    get
  }
}
extension Dispatch.DispatchQueue {
  public static func isCurrent(_ queue: Dispatch.DispatchQueue) -> Swift.Bool
}
extension CoreGraphics.CGPoint {
  public func distance(from point: CoreGraphics.CGPoint) -> CoreGraphics.CGFloat
  public static func distance(from point1: CoreGraphics.CGPoint, to point2: CoreGraphics.CGPoint) -> CoreGraphics.CGFloat
}
extension CoreGraphics.CGPoint {
  public static func + (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
  public static func += (lhs: inout CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint)
  public static func - (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
  public static func -= (lhs: inout CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint)
  public static func * (point: CoreGraphics.CGPoint, scalar: CoreGraphics.CGFloat) -> CoreGraphics.CGPoint
  public static func *= (point: inout CoreGraphics.CGPoint, scalar: CoreGraphics.CGFloat)
  public static func * (scalar: CoreGraphics.CGFloat, point: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
}
extension Swift.Collection {
  public func forEachInParallel(_ each: (Self.Element) -> Swift.Void)
  public subscript(safe index: Self.Index) -> Self.Element? {
    get
  }
  public func group(by size: Swift.Int) -> [[Self.Element]]?
}
extension Swift.Collection where Self.Index == Swift.Int {
  public func indices(where condition: (Self.Element) throws -> Swift.Bool) rethrows -> [Self.Index]?
  public func forEach(slice: Swift.Int, body: ([Self.Element]) throws -> Swift.Void) rethrows
}
extension Swift.Collection where Self.Element == Swift.IntegerLiteralType, Self.Index == Swift.Int {
  public func average() -> Swift.Double
}
extension Swift.Collection where Self.Element : Swift.FloatingPoint {
  public func average() -> Self.Element
}
@_hasMissingDesignatedInitializers public class AllowedCharacterRule : CPCoreKit.PasswordRule {
  public var disallowedCharacters: Foundation.CharacterSet?
  convenience public init(allowedCharacters: Foundation.CharacterSet)
  public func evaluate(_ password: Swift.String) -> Swift.Bool
  public var localizedErrorDescription: Swift.String {
    get
  }
  @objc deinit
}
extension Swift.Dictionary {
  public init<S>(grouping sequence: S, by keyPath: Swift.KeyPath<S.Element, Key>) where Value == [S.Element], S : Swift.Sequence
  public func has(key: Key) -> Swift.Bool
  public mutating func removeAll<S>(keys: S) where Key == S.Element, S : Swift.Sequence
  @discardableResult
  public mutating func removeValueForRandomKey() -> Value?
  public func jsonData(prettify: Swift.Bool = false) -> Foundation.Data?
  public func jsonString(prettify: Swift.Bool = false) -> Swift.String?
  public func mapKeysAndValues<K, V>(_ transform: ((key: Key, value: Value)) throws -> (K, V)) rethrows -> [K : V] where K : Swift.Hashable
  public func compactMapKeysAndValues<K, V>(_ transform: ((key: Key, value: Value)) throws -> (K, V)?) rethrows -> [K : V] where K : Swift.Hashable
}
extension Swift.Dictionary where Value : Swift.Equatable {
  public func keys(forValue value: Value) -> [Key]
}
extension Swift.Dictionary where Key : Swift.StringProtocol {
  public mutating func lowercaseAllKeys()
}
extension Swift.Dictionary {
  public subscript(path path: [Key]) -> Any? {
    get
    set
  }
}
extension Swift.Dictionary {
  public static func + (lhs: [Key : Value], rhs: [Key : Value]) -> [Key : Value]
  public static func += (lhs: inout [Key : Value], rhs: [Key : Value])
  public static func - <S>(lhs: [Key : Value], keys: S) -> [Key : Value] where Key == S.Element, S : Swift.Sequence
  public static func -= <S>(lhs: inout [Key : Value], keys: S) where Key == S.Element, S : Swift.Sequence
}
extension Swift.Bool {
  public func stringValue() -> Swift.String
  public static func fromStringValue(_ value: Swift.String?) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class RegularExpressionRule : CPCoreKit.PasswordRule {
  public var regularExpression: Foundation.NSRegularExpression?
  convenience public init(regularExpression: Foundation.NSRegularExpression)
  public func evaluate(_ password: Swift.String) -> Swift.Bool
  public var localizedErrorDescription: Swift.String {
    get
  }
  @objc deinit
}
extension CPCoreKit.Promise {
  public func recover(in context: CPCoreKit.Context? = nil, _ body: @escaping (Swift.Error) throws -> CPCoreKit.Promise<Value>) -> CPCoreKit.Promise<Value>
}
@objc @_inheritsConvenienceInitializers open class AsynchronousOperation : Foundation.Operation {
  @objc final override public var isReady: Swift.Bool {
    @objc get
  }
  @objc final override public var isExecuting: Swift.Bool {
    @objc get
  }
  @objc final override public var isFinished: Swift.Bool {
    @objc get
  }
  @objc final override public var isAsynchronous: Swift.Bool {
    @objc get
  }
  @objc override final public func start()
  open func execute()
  public func notifyWithDelay()
  @objc override dynamic public init()
  @objc deinit
}
public enum ReportRange : Swift.CustomStringConvertible {
  case overview
  case today
  case day(date: Foundation.Date)
  case range(from: Foundation.Date, to: Foundation.Date)
  public var caseInt: Swift.Int {
    get
  }
  public var isRange: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
  public static func range(from: Foundation.Date, to: Foundation.Date? = nil) -> CPCoreKit.ReportRange
  public var requestHeaders: [Swift.String : Swift.String] {
    get
  }
  public var requestBody: [Swift.String : Swift.String]? {
    get
  }
}
extension Foundation.Formatter {
  public enum DayOfMonth {
    case first
    case last
    public static func == (a: Foundation.Formatter.DayOfMonth, b: Foundation.Formatter.DayOfMonth) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func dateFromEpochWithMilliseconds(_ s: Swift.String) -> Foundation.Date?
  public static func dateFromEpochWithMilliseconds(_ i: Swift.Double) -> Foundation.Date?
  public static func dateFromString(_ dateString: Swift.String, customFormat: Swift.String? = nil) -> Foundation.Date
  public static func dateFromStringFailabale(_ dateString: Swift.String, customFormat: Swift.String? = nil) -> Foundation.Date?
  public static func dateWithMillisecondsString(_ dateString: Swift.String) -> Foundation.Date?
  public static func internetStringFromDate(_ date: Foundation.Date) -> Swift.String
  public static func internetStringFromDateAndMilliseconds(_ date: Foundation.Date) -> Swift.String
  public static func dateFromInternetString(_ string: Swift.String) -> Foundation.Date
  public static func dateFromSlashedDateString(_ string: Swift.String, inCalendar calendar: Foundation.Calendar = Calendar.init(identifier: .gregorian)) -> Foundation.Date?
  public static func dateFromDay(_ day: Swift.Int, month: Swift.Int, year: Swift.Int, inCalendar calendar: Foundation.Calendar = Calendar.init(identifier: .gregorian)) -> Foundation.Date?
  public static func shortFormatString(_ date: Foundation.Date) -> Swift.String
  public static func shortSlashedFormat(_ date: Foundation.Date) -> Swift.String
  public static func shortFormatStringWithTime(_ date: Foundation.Date, replaceMidnight replace: Swift.Bool) -> Swift.String
  public static func timeZoneAbbreviation(_ date: Foundation.Date) -> Swift.String?
  public static func stringFromDateInMonthDayYearShortTime(_ date: Foundation.Date, separator: Swift.String = "-") -> Swift.String
  public static func dateFrom(month: Swift.String, year: Swift.String, dayOfTheMonth: Foundation.Formatter.DayOfMonth) -> Foundation.Date?
}
extension Foundation.URL {
  public var queryParameters: [Swift.String : Swift.String]? {
    get
  }
}
extension Foundation.URL {
  public func appendingQueryParameters(_ parameters: [Swift.String : Swift.String]) -> Foundation.URL
  public mutating func appendQueryParameters(_ parameters: [Swift.String : Swift.String])
  public func queryValue(for key: Swift.String) -> Swift.String?
  public func deletingAllPathComponents() -> Foundation.URL
  public mutating func deleteAllPathComponents()
  public func droppedScheme() -> Foundation.URL?
}
extension Foundation.URL {
  public func thumbnail(fromTime time: Swift.Float64 = 0) -> UIKit.UIImage?
}
extension UIKit.UICollectionView {
  @_Concurrency.MainActor(unsafe) public var indexPathForLastItem: Foundation.IndexPath? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var lastSection: Swift.Int {
    get
  }
}
extension UIKit.UICollectionView {
  @_Concurrency.MainActor(unsafe) public func numberOfItems() -> Swift.Int
  @_Concurrency.MainActor(unsafe) public func indexPathForLastItem(inSection section: Swift.Int) -> Foundation.IndexPath?
  @_Concurrency.MainActor(unsafe) public func reloadData(_ completion: @escaping () -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func dequeueReusableCell<T>(withClass name: T.Type, for indexPath: Foundation.IndexPath) -> T where T : UIKit.UICollectionViewCell
  @_Concurrency.MainActor(unsafe) public func dequeueReusableSupplementaryView<T>(ofKind kind: Swift.String, withClass name: T.Type, for indexPath: Foundation.IndexPath) -> T where T : UIKit.UICollectionReusableView
  @_Concurrency.MainActor(unsafe) public func register<T>(supplementaryViewOfKind kind: Swift.String, withClass name: T.Type) where T : UIKit.UICollectionReusableView
  @_Concurrency.MainActor(unsafe) public func register<T>(nib: UIKit.UINib?, forCellWithClass name: T.Type) where T : UIKit.UICollectionViewCell
  @_Concurrency.MainActor(unsafe) public func register<T>(cellWithClass name: T.Type) where T : UIKit.UICollectionViewCell
  @_Concurrency.MainActor(unsafe) public func register<T>(nib: UIKit.UINib?, forSupplementaryViewOfKind kind: Swift.String, withClass name: T.Type) where T : UIKit.UICollectionReusableView
  @_Concurrency.MainActor(unsafe) public func register<T>(nibWithCellClass name: T.Type, at bundleClass: Swift.AnyClass? = nil) where T : UIKit.UICollectionViewCell
  @_Concurrency.MainActor(unsafe) public func safeScrollToItem(at indexPath: Foundation.IndexPath, at scrollPosition: UIKit.UICollectionView.ScrollPosition, animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func isValidIndexPath(_ indexPath: Foundation.IndexPath) -> Swift.Bool
}
extension Swift.Comparable {
  public func isBetween(_ range: Swift.ClosedRange<Self>) -> Swift.Bool
  public func clamped(to range: Swift.ClosedRange<Self>) -> Self
}
public enum CPError : Swift.Error, Swift.CustomStringConvertible {
  case networkUnreachable
  case requestError(CPCoreKit.CPInvalidRequest)
  case nilValue(type: Swift.String, value: Swift.String)
  case unknownError
  case expiredToken
  case reloginNeeded
  case uninitializedFramework
  case unsuportedOperation(Swift.String)
  case invalidUrl
  case suspendedAccount
  case lockedAccount
  case invalidCredentials
  case invalidSubscriptionStatus
  case partiallyRegisteredUser
  public var description: Swift.String {
    get
  }
  public var isKycError: Swift.Bool {
    get
  }
}
extension Swift.String {
  public func networkDescription(withData data: Foundation.Data?) -> Swift.String
}
extension Swift.BidirectionalCollection {
  public subscript(offset distance: Swift.Int) -> Self.Element {
    get
  }
}
extension UIKit.UIGestureRecognizer {
  @_Concurrency.MainActor(unsafe) public func removeFromView()
}
@_hasMissingDesignatedInitializers public class BlockRule : CPCoreKit.PasswordRule {
  public var evaluation: ((Swift.String) -> Swift.Bool)?
  convenience public init(evaluation: @escaping (Swift.String) -> Swift.Bool)
  public func evaluate(_ password: Swift.String) -> Swift.Bool
  public var localizedErrorDescription: Swift.String {
    get
  }
  @objc deinit
}
extension Foundation.UserDefaults {
  public subscript(key: Swift.String) -> Any? {
    get
    set
  }
  public func float(forKey key: Swift.String) -> Swift.Float?
  public func date(forKey key: Swift.String) -> Foundation.Date?
  public func object<T>(_ type: T.Type, with key: Swift.String, usingDecoder decoder: Foundation.JSONDecoder = JSONDecoder()) -> T? where T : Swift.Decodable, T : Swift.Encodable
  public func set<T>(object: T, forKey key: Swift.String, usingEncoder encoder: Foundation.JSONEncoder = JSONEncoder()) where T : Swift.Decodable, T : Swift.Encodable
}
extension UIKit.UIImageView {
  @_Concurrency.MainActor(unsafe) public func download(from url: Foundation.URL, contentMode: UIKit.UIView.ContentMode = .scaleAspectFit, placeholder: UIKit.UIImage? = nil, completionHandler: ((UIKit.UIImage?) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func blur(withStyle style: UIKit.UIBlurEffect.Style = .light)
  @_Concurrency.MainActor(unsafe) public func blurred(withStyle style: UIKit.UIBlurEffect.Style = .light) -> UIKit.UIImageView
}
extension Swift.Array {
  public mutating func prepend(_ newElement: Element)
  public mutating func safeSwap(from index: Swift.Array<Element>.Index, to otherIndex: Swift.Array<Element>.Index)
  public func sorted<T>(like otherArray: [T], keyPath: Swift.KeyPath<Element, T>) -> [Element] where T : Swift.Hashable
}
extension Swift.Array where Element : Swift.Equatable {
  @discardableResult
  public mutating func removeAll(_ item: Element) -> [Element]
  @discardableResult
  public mutating func removeAll(_ items: [Element]) -> [Element]
  @discardableResult
  public mutating func removeDuplicates() -> [Element]
  public func withoutDuplicates() -> [Element]
  public func withoutDuplicates<E>(keyPath path: Swift.KeyPath<Element, E>) -> [Element] where E : Swift.Equatable
  public func withoutDuplicates<E>(keyPath path: Swift.KeyPath<Element, E>) -> [Element] where E : Swift.Hashable
}
@_hasMissingDesignatedInitializers public class PasswordValidator {
  public var rules: [CPCoreKit.PasswordRule]
  public static var standard: CPCoreKit.PasswordValidator {
    get
  }
  public static var standardLengthRule: CPCoreKit.LengthRule {
    get
  }
  convenience public init(rules: [CPCoreKit.PasswordRule])
  public func validate(_ password: Swift.String) -> [CPCoreKit.PasswordRule]?
  @objc deinit
}
extension UIKit.UISwitch {
  @_Concurrency.MainActor(unsafe) public func toggle(animated: Swift.Bool = true)
}
extension UIKit.UISearchBar {
  @_Concurrency.MainActor(unsafe) public var textField: UIKit.UITextField? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var trimmedText: Swift.String? {
    get
  }
}
extension UIKit.UISearchBar {
  @_Concurrency.MainActor(unsafe) public func clear()
}
extension Swift.MutableCollection where Self : Swift.RandomAccessCollection {
  public mutating func sort<T>(by keyPath: Swift.KeyPath<Self.Element, T>, with compare: (T, T) -> Swift.Bool)
  public mutating func sort<T>(by keyPath: Swift.KeyPath<Self.Element, T>) where T : Swift.Comparable
  public mutating func sort<T, U>(by keyPath1: Swift.KeyPath<Self.Element, T>, and keyPath2: Swift.KeyPath<Self.Element, U>) where T : Swift.Comparable, U : Swift.Comparable
  public mutating func sort<T, U, V>(by keyPath1: Swift.KeyPath<Self.Element, T>, and keyPath2: Swift.KeyPath<Self.Element, U>, and keyPath3: Swift.KeyPath<Self.Element, V>) where T : Swift.Comparable, U : Swift.Comparable, V : Swift.Comparable
}
extension Swift.MutableCollection {
  public mutating func assignToAll<Value>(value: Value, by keyPath: Swift.WritableKeyPath<Self.Element, Value>)
}
extension UIKit.UIView {
  public enum ShakeDirection {
    case horizontal
    case vertical
    public static func == (a: UIKit.UIView.ShakeDirection, b: UIKit.UIView.ShakeDirection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum AngleUnit {
    case degrees
    case radians
    public static func == (a: UIKit.UIView.AngleUnit, b: UIKit.UIView.AngleUnit) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ShakeAnimationType {
    case linear
    case easeIn
    case easeOut
    case easeInOut
    public static func == (a: UIKit.UIView.ShakeAnimationType, b: UIKit.UIView.ShakeAnimationType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension UIKit.UIView {
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var borderColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var borderWidth: CoreGraphics.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var cornerRadius: CoreGraphics.CGFloat {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var height: CoreGraphics.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var isRightToLeft: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public var screenshot: UIKit.UIImage? {
    get
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var shadowColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var shadowOffset: CoreGraphics.CGSize {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var shadowOpacity: Swift.Float {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var shadowRadius: CoreGraphics.CGFloat {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var size: CoreGraphics.CGSize {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var parentViewController: UIKit.UIViewController? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var width: CoreGraphics.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var x: CoreGraphics.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var y: CoreGraphics.CGFloat {
    get
    set
  }
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func firstResponder() -> UIKit.UIView?
  @_Concurrency.MainActor(unsafe) public func roundCorners(_ corners: UIKit.UIRectCorner, radius: CoreGraphics.CGFloat)
  @_Concurrency.MainActor(unsafe) public func addShadow(ofColor color: UIKit.UIColor = UIColor(red: 0.07, green: 0.47, blue: 0.57, alpha: 1.0), radius: CoreGraphics.CGFloat = 3, offset: CoreGraphics.CGSize = .zero, opacity: Swift.Float = 0.5)
  @_Concurrency.MainActor(unsafe) public func addSubviews(_ subviews: [UIKit.UIView])
  @_Concurrency.MainActor(unsafe) public func fadeIn(duration: Foundation.TimeInterval = 1, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func fadeOut(duration: Foundation.TimeInterval = 1, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public class func loadFromNib(named name: Swift.String, bundle: Foundation.Bundle? = nil) -> UIKit.UIView?
  @_Concurrency.MainActor(unsafe) public func removeSubviews()
  @_Concurrency.MainActor(unsafe) public func removeGestureRecognizers()
  @_Concurrency.MainActor(unsafe) public func addGestureRecognizers(_ gestureRecognizers: [UIKit.UIGestureRecognizer])
  @_Concurrency.MainActor(unsafe) public func removeGestureRecognizers(_ gestureRecognizers: [UIKit.UIGestureRecognizer])
  @_Concurrency.MainActor(unsafe) public func rotate(byAngle angle: CoreGraphics.CGFloat, ofType type: UIKit.UIView.AngleUnit, animated: Swift.Bool = false, duration: Foundation.TimeInterval = 1, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func rotate(toAngle angle: CoreGraphics.CGFloat, ofType type: UIKit.UIView.AngleUnit, animated: Swift.Bool = false, duration: Foundation.TimeInterval = 1, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func scale(by offset: CoreGraphics.CGPoint, animated: Swift.Bool = false, duration: Foundation.TimeInterval = 1, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func shake(direction: UIKit.UIView.ShakeDirection = .horizontal, duration: Foundation.TimeInterval = 1, animationType: UIKit.UIView.ShakeAnimationType = .easeOut, completion: (() -> Swift.Void)? = nil)
  @available(iOS 9, *)
  @_Concurrency.MainActor(unsafe) public func addConstraints(withFormat: Swift.String, views: UIKit.UIView...)
  @available(iOS 9, *)
  @_Concurrency.MainActor(unsafe) public func fillToSuperview()
  @available(iOS 9, *)
  @discardableResult
  @_Concurrency.MainActor(unsafe) public func anchor(top: UIKit.NSLayoutYAxisAnchor? = nil, left: UIKit.NSLayoutXAxisAnchor? = nil, bottom: UIKit.NSLayoutYAxisAnchor? = nil, right: UIKit.NSLayoutXAxisAnchor? = nil, topConstant: CoreGraphics.CGFloat = 0, leftConstant: CoreGraphics.CGFloat = 0, bottomConstant: CoreGraphics.CGFloat = 0, rightConstant: CoreGraphics.CGFloat = 0, widthConstant: CoreGraphics.CGFloat = 0, heightConstant: CoreGraphics.CGFloat = 0) -> [UIKit.NSLayoutConstraint]
  @available(iOS 9, *)
  @_Concurrency.MainActor(unsafe) public func anchorCenterXToSuperview(constant: CoreGraphics.CGFloat = 0)
  @available(iOS 9, *)
  @_Concurrency.MainActor(unsafe) public func anchorCenterYToSuperview(constant: CoreGraphics.CGFloat = 0)
  @available(iOS 9, *)
  @_Concurrency.MainActor(unsafe) public func anchorCenterSuperview()
  @_Concurrency.MainActor(unsafe) public func ancestorView(where predicate: (UIKit.UIView?) -> Swift.Bool) -> UIKit.UIView?
  @_Concurrency.MainActor(unsafe) public func ancestorView<T>(withClass name: T.Type) -> T? where T : UIKit.UIView
}
public enum CPSortOrder : Swift.String {
  case ascending, descending
  public var switchRequestValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension SceneKit.SCNSphere {
  convenience public init(diameter: CoreGraphics.CGFloat)
  convenience public init(radius: CoreGraphics.CGFloat, material: SceneKit.SCNMaterial)
  convenience public init(radius: CoreGraphics.CGFloat, color: CPCoreKit.Color)
  convenience public init(diameter: CoreGraphics.CGFloat, material: SceneKit.SCNMaterial)
  convenience public init(diameter: CoreGraphics.CGFloat, color: CPCoreKit.Color)
}
extension Foundation.URLRequest {
  public init?(urlString: Swift.String)
  public var curlString: Swift.String {
    get
  }
}
extension UIKit.UIButton {
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var imageForDisabled: UIKit.UIImage? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var imageForHighlighted: UIKit.UIImage? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var imageForNormal: UIKit.UIImage? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var imageForSelected: UIKit.UIImage? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var titleColorForDisabled: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var titleColorForHighlighted: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var titleColorForNormal: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var titleColorForSelected: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var titleForDisabled: Swift.String? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var titleForHighlighted: Swift.String? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var titleForNormal: Swift.String? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var titleForSelected: Swift.String? {
    @objc get
    @objc set
  }
}
extension UIKit.UIButton {
  @_Concurrency.MainActor(unsafe) public func setImageForAllStates(_ image: UIKit.UIImage)
  @_Concurrency.MainActor(unsafe) public func setTitleColorForAllStates(_ color: UIKit.UIColor)
  @_Concurrency.MainActor(unsafe) public func setTitleForAllStates(_ title: Swift.String)
  @_Concurrency.MainActor(unsafe) public func centerTextAndImage(spacing: CoreGraphics.CGFloat)
}
extension Foundation.Bundle {
  public static func keychainPrefix() -> Swift.String
}
extension Foundation.Date {
  public enum DayNameStyle {
    case threeLetters
    case oneLetter
    case full
    public static func == (a: Foundation.Date.DayNameStyle, b: Foundation.Date.DayNameStyle) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum MonthNameStyle {
    case threeLetters
    case oneLetter
    case full
    public static func == (a: Foundation.Date.MonthNameStyle, b: Foundation.Date.MonthNameStyle) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Foundation.Date {
  public var calendar: Foundation.Calendar {
    get
  }
  public var era: Swift.Int {
    get
  }
  public var quarter: Swift.Int {
    get
  }
  public var weekOfYear: Swift.Int {
    get
  }
  public var weekOfMonth: Swift.Int {
    get
  }
  public var year: Swift.Int {
    get
    set
  }
  public var month: Swift.Int {
    get
    set
  }
  public var day: Swift.Int {
    get
    set
  }
  public var weekday: Swift.Int {
    get
  }
  public var hour: Swift.Int {
    get
    set
  }
  public var minute: Swift.Int {
    get
    set
  }
  public var second: Swift.Int {
    get
    set
  }
  public var nanosecond: Swift.Int {
    get
    set
  }
  public var millisecond: Swift.Int {
    get
    set
  }
  public var isInFuture: Swift.Bool {
    get
  }
  public var isInPast: Swift.Bool {
    get
  }
  public var isInToday: Swift.Bool {
    get
  }
  public var isInYesterday: Swift.Bool {
    get
  }
  public var isInTomorrow: Swift.Bool {
    get
  }
  public var isInWeekend: Swift.Bool {
    get
  }
  public var isWorkday: Swift.Bool {
    get
  }
  public var isInCurrentWeek: Swift.Bool {
    get
  }
  public var isInCurrentMonth: Swift.Bool {
    get
  }
  public var isInCurrentYear: Swift.Bool {
    get
  }
  public var iso8601String: Swift.String {
    get
  }
  public var nearestFiveMinutes: Foundation.Date {
    get
  }
  public var nearestTenMinutes: Foundation.Date {
    get
  }
  public var nearestQuarterHour: Foundation.Date {
    get
  }
  public var nearestHalfHour: Foundation.Date {
    get
  }
  public var nearestHour: Foundation.Date {
    get
  }
  public var yesterday: Foundation.Date {
    get
  }
  public var tomorrow: Foundation.Date {
    get
  }
  public var unixTimestamp: Swift.Double {
    get
  }
}
extension Foundation.Date {
  public func adding(_ component: Foundation.Calendar.Component, value: Swift.Int) -> Foundation.Date
  public mutating func add(_ component: Foundation.Calendar.Component, value: Swift.Int)
  public func changing(_ component: Foundation.Calendar.Component, value: Swift.Int) -> Foundation.Date?
  public func beginning(of component: Foundation.Calendar.Component) -> Foundation.Date?
  public func end(of component: Foundation.Calendar.Component) -> Foundation.Date?
  public func isInCurrent(_ component: Foundation.Calendar.Component) -> Swift.Bool
  public func string(withFormat format: Swift.String = "dd/MM/yyyy HH:mm") -> Swift.String
  public func dateString(ofStyle style: Foundation.DateFormatter.Style = .medium) -> Swift.String
  public func monthNameDayYearString(addTime: Swift.Bool) -> Swift.String
  public func dateTimeString(ofStyle style: Foundation.DateFormatter.Style = .medium) -> Swift.String
  public func timeString(ofStyle style: Foundation.DateFormatter.Style = .medium) -> Swift.String
  public func dayName(ofStyle style: Foundation.Date.DayNameStyle = .full) -> Swift.String
  public func monthName(ofStyle style: Foundation.Date.MonthNameStyle = .full) -> Swift.String
  public func secondsSince(_ date: Foundation.Date) -> Swift.Double
  public func minutesSince(_ date: Foundation.Date) -> Swift.Double
  public func hoursSince(_ date: Foundation.Date) -> Swift.Double
  public func daysSince(_ date: Foundation.Date) -> Swift.Double
  public func isBetween(_ startDate: Foundation.Date, _ endDate: Foundation.Date, includeBounds: Swift.Bool = false) -> Swift.Bool
  public func isWithin(_ value: Swift.UInt, _ component: Foundation.Calendar.Component, of date: Foundation.Date) -> Swift.Bool
  public static func random(in range: Swift.Range<Foundation.Date>) -> Foundation.Date
  public static func random(in range: Swift.ClosedRange<Foundation.Date>) -> Foundation.Date
  public static func random<T>(in range: Swift.Range<Foundation.Date>, using generator: inout T) -> Foundation.Date where T : Swift.RandomNumberGenerator
  public static func random<T>(in range: Swift.ClosedRange<Foundation.Date>, using generator: inout T) -> Foundation.Date where T : Swift.RandomNumberGenerator
}
extension Foundation.Date {
  public init?(calendar: Foundation.Calendar? = Calendar.current, timeZone: Foundation.TimeZone? = NSTimeZone.default, era: Swift.Int? = Date().era, year: Swift.Int? = Date().year, month: Swift.Int? = Date().month, day: Swift.Int? = Date().day, hour: Swift.Int? = Date().hour, minute: Swift.Int? = Date().minute, second: Swift.Int? = Date().second, nanosecond: Swift.Int? = Date().nanosecond)
  public init?(iso8601String: Swift.String)
  public init(unixTimestamp: Swift.Double)
  public init?(integerLiteral value: Swift.Int)
}
public typealias SceneKitFloat = Swift.Float
extension SceneKit.SCNVector3 {
  public var absolute: SceneKit.SCNVector3 {
    get
  }
  public var length: CPCoreKit.SceneKitFloat {
    get
  }
}
extension SceneKit.SCNVector3 {
  public static func + (lhs: SceneKit.SCNVector3, rhs: SceneKit.SCNVector3) -> SceneKit.SCNVector3
  public static func += (lhs: inout SceneKit.SCNVector3, rhs: SceneKit.SCNVector3)
  public static func - (lhs: SceneKit.SCNVector3, rhs: SceneKit.SCNVector3) -> SceneKit.SCNVector3
  public static func -= (lhs: inout SceneKit.SCNVector3, rhs: SceneKit.SCNVector3)
  public static func * (vector: SceneKit.SCNVector3, scalar: CPCoreKit.SceneKitFloat) -> SceneKit.SCNVector3
  public static func *= (vector: inout SceneKit.SCNVector3, scalar: CPCoreKit.SceneKitFloat)
  public static func * (scalar: CPCoreKit.SceneKitFloat, vector: SceneKit.SCNVector3) -> SceneKit.SCNVector3
}
public protocol CPDataCaching {
  func cachedData(for key: Swift.String) -> Foundation.Data?
  func storeData(_ data: Foundation.Data, for key: Swift.String)
}
final public class LCDataCache : CPCoreKit.CPDataCaching {
  public typealias Key = Swift.String
  final public var countLimit: Swift.Int
  final public var sizeLimit: Swift.Int
  final public let path: Foundation.URL
  final public var sweepInterval: Swift.Double
  public typealias FilenameGenerator = (_ key: Swift.String) -> Swift.String?
  convenience public init(name: Swift.String, filenameGenerator: @escaping (Swift.String) -> Swift.String? = LCDataCache.filename(for:)) throws
  public init(path: Foundation.URL, filenameGenerator: @escaping (Swift.String) -> Swift.String? = LCDataCache.filename(for:)) throws
  public static func filename(for key: Swift.String) -> Swift.String?
  final public func cachedData(for key: CPCoreKit.LCDataCache.Key) -> Foundation.Data?
  final public func storeData(_ data: Foundation.Data, for key: CPCoreKit.LCDataCache.Key)
  final public func removeData(for key: CPCoreKit.LCDataCache.Key)
  final public func removeAll()
  final public subscript(key: CPCoreKit.LCDataCache.Key) -> Foundation.Data? {
    get
    set
  }
  final public func filename(for key: CPCoreKit.LCDataCache.Key) -> Swift.String?
  final public func flush()
  final public func sweep()
  final public var totalCount: Swift.Int {
    get
  }
  final public var totalSize: Swift.Int {
    get
  }
  final public var totalAllocatedSize: Swift.Int {
    get
  }
  @objc deinit
}
public struct Country : Swift.Decodable {
  public var flag: Swift.String {
    get
  }
  public let code: Swift.String
  public var name: Swift.String {
    get
  }
  public var title: Swift.String {
    get
  }
  public let dialCode: Swift.String?
  public static func getCurrentCountry() -> CPCoreKit.Country?
  public init(from decoder: Swift.Decoder) throws
}
extension UIKit.UIImageView {
  @_Concurrency.MainActor(unsafe) convenience public init(qrCode: CPCoreKit.CPQRCode)
}
extension Swift.RangeReplaceableCollection {
  public init(expression: @autoclosure () throws -> Self.Element, count: Swift.Int) rethrows
}
extension Swift.RangeReplaceableCollection {
  public func rotated(by places: Swift.Int) -> Self
  @discardableResult
  public mutating func rotate(by places: Swift.Int) -> Self
  @discardableResult
  public mutating func removeFirst(where predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Element?
  @discardableResult
  public mutating func removeRandomElement() -> Self.Element?
  @discardableResult
  public mutating func keep(while condition: (Self.Element) throws -> Swift.Bool) rethrows -> Self
  public func take(while condition: (Self.Element) throws -> Swift.Bool) rethrows -> Self
  public func skip(while condition: (Self.Element) throws -> Swift.Bool) rethrows -> Self
  public mutating func removeDuplicates<E>(keyPath path: Swift.KeyPath<Self.Element, E>) where E : Swift.Equatable
  public mutating func removeDuplicates<E>(keyPath path: Swift.KeyPath<Self.Element, E>) where E : Swift.Hashable
}
extension Swift.Int {
  public var string: Swift.String {
    get
  }
}
public class CPImagePipeline {
  final public let configuration: CPCoreKit.CPImagePipeline.CPNukeConfiguration
  public static var shared: CPCoreKit.CPImagePipeline
  public init(configuration: CPCoreKit.CPImagePipeline.CPNukeConfiguration = CPNukeConfiguration())
  convenience public init(_ configure: (inout CPCoreKit.CPImagePipeline.CPNukeConfiguration) -> Swift.Void)
  @discardableResult
  public func loadImage(with url: Foundation.URL, progress: CPCoreKit.CPImageTask.ProgressHandler? = nil, completion: CPCoreKit.CPImageTask.Completion? = nil) -> CPCoreKit.CPImageTask
  @discardableResult
  public func loadImage(with request: CPCoreKit.CPImageRequest, progress progressHandler: CPCoreKit.CPImageTask.ProgressHandler? = nil, completion: CPCoreKit.CPImageTask.Completion? = nil) -> CPCoreKit.CPImageTask
  @discardableResult
  public func loadData(with request: CPCoreKit.CPImageRequest, progress: ((_ completed: Swift.Int64, _ total: Swift.Int64) -> Swift.Void)? = nil, completion: @escaping (Swift.Result<(data: Foundation.Data, response: Foundation.URLResponse?), CPCoreKit.CPImagePipeline.Error>) -> Swift.Void) -> CPCoreKit.CPImageTask
  public func cachedResponse(for request: CPCoreKit.CPImageRequest) -> CPCoreKit.CPImageResponse?
  public enum Error : Swift.Error, Swift.CustomDebugStringConvertible {
    case dataLoadingFailed(Swift.Error)
    case decodingFailed
    case processingFailed
    public var debugDescription: Swift.String {
      get
    }
  }
  @objc deinit
}
extension UIKit.UIBezierPath {
  convenience public init(from: CoreGraphics.CGPoint, to otherPoint: CoreGraphics.CGPoint)
  convenience public init(points: [CoreGraphics.CGPoint])
  convenience public init?(polygonWithPoints points: [CoreGraphics.CGPoint])
  convenience public init(ovalOf size: CoreGraphics.CGSize, centered: Swift.Bool)
  convenience public init(rectOf size: CoreGraphics.CGSize, centered: Swift.Bool)
}
extension SceneKit.SCNPlane {
  convenience public init(width: CoreGraphics.CGFloat)
  convenience public init(width: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, material: SceneKit.SCNMaterial)
  convenience public init(width: CoreGraphics.CGFloat, material: SceneKit.SCNMaterial)
  convenience public init(width: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, color: CPCoreKit.Color)
  convenience public init(width: CoreGraphics.CGFloat, color: CPCoreKit.Color)
}
extension UIKit.UIBarButtonItem {
  @_Concurrency.MainActor(unsafe) public static var flexibleSpace: UIKit.UIBarButtonItem {
    get
  }
}
extension UIKit.UIBarButtonItem {
  @_Concurrency.MainActor(unsafe) public func addTargetForAction(_ target: Swift.AnyObject, action: ObjectiveC.Selector)
  @_Concurrency.MainActor(unsafe) public static func fixedSpace(width: CoreGraphics.CGFloat) -> UIKit.UIBarButtonItem
}
extension Foundation.OperationQueue {
  public func add(_ o: @escaping () -> ())
}
public enum PromiseResolveType {
  case parallel
  case series
  public static func == (a: CPCoreKit.PromiseResolveType, b: CPCoreKit.PromiseResolveType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public func map<A, B, S>(_ context: CPCoreKit.Context? = nil, as type: CPCoreKit.PromiseResolveType, _ items: S, _ transform: @escaping (A) throws -> CPCoreKit.Promise<B>) -> CPCoreKit.Promise<[B]> where A == S.Element, S : Swift.Sequence
public func map_series<A, B, S>(context: CPCoreKit.Context, items: S, transform: @escaping (A) throws -> CPCoreKit.Promise<B>) -> CPCoreKit.Promise<[B]> where A == S.Element, S : Swift.Sequence
extension Foundation.Locale {
  public static var posix: Foundation.Locale {
    get
  }
  public var is12HourTimeFormat: Swift.Bool {
    get
  }
}
extension Swift.Array {
  @available(*, deprecated, message: "Use sorted(by:with:) instead.")
  public func sorted<T>(by path: Swift.KeyPath<Element, T?>, ascending: Swift.Bool) -> [Element] where T : Swift.Comparable
  @available(*, deprecated, message: "Use sorted(by:with:) instead.")
  public func sorted<T>(by path: Swift.KeyPath<Element, T>, ascending: Swift.Bool) -> [Element] where T : Swift.Comparable
  @available(*, deprecated, message: "Use sort(by:with:) instead.")
  @discardableResult
  public mutating func sort<T>(by path: Swift.KeyPath<Element, T?>, ascending: Swift.Bool) -> [Element] where T : Swift.Comparable
  @available(*, deprecated, message: "Use sort(by:with:) instead.")
  @discardableResult
  public mutating func sort<T>(by path: Swift.KeyPath<Element, T>, ascending: Swift.Bool) -> [Element] where T : Swift.Comparable
}
extension Foundation.OperationQueue {
  public static func currentQueue() -> Foundation.OperationQueue
}
public protocol CPImageCaching : AnyObject {
  func cachedResponse(for request: CPCoreKit.CPImageRequest) -> CPCoreKit.CPImageResponse?
  func storeResponse(_ response: CPCoreKit.CPImageResponse, for request: CPCoreKit.CPImageRequest)
  func removeResponse(for request: CPCoreKit.CPImageRequest)
}
extension CPCoreKit.CPImageCaching {
  public subscript(request: CPCoreKit.CPImageRequest) -> CPCoreKit.CPImage? {
    get
    set
  }
}
final public class CPImageCache : CPCoreKit.CPImageCaching {
  final public var costLimit: Swift.Int {
    get
    set
  }
  final public var countLimit: Swift.Int {
    get
    set
  }
  final public var ttl: Foundation.TimeInterval {
    get
    set
  }
  final public var totalCost: Swift.Int {
    get
  }
  final public var totalCount: Swift.Int {
    get
  }
  public static let shared: CPCoreKit.CPImageCache
  public init(costLimit: Swift.Int = CPImageCache.defaultCostLimit(), countLimit: Swift.Int = Int.max)
  public static func defaultCostLimit() -> Swift.Int
  final public func cachedResponse(for request: CPCoreKit.CPImageRequest) -> CPCoreKit.CPImageResponse?
  final public func storeResponse(_ response: CPCoreKit.CPImageResponse, for request: CPCoreKit.CPImageRequest)
  final public func removeResponse(for request: CPCoreKit.CPImageRequest)
  final public func removeAll()
  final public func trim(toCost limit: Swift.Int)
  final public func trim(toCount limit: Swift.Int)
  @objc deinit
}
public typealias Color = UIKit.UIColor
extension UIKit.UIColor {
  public static var random: CPCoreKit.Color {
    get
  }
  public var rgbComponents: (red: Swift.Int, green: Swift.Int, blue: Swift.Int) {
    get
  }
  public var cgFloatComponents: (red: CoreGraphics.CGFloat, green: CoreGraphics.CGFloat, blue: CoreGraphics.CGFloat) {
    get
  }
  public var hsbaComponents: (hue: CoreGraphics.CGFloat, saturation: CoreGraphics.CGFloat, brightness: CoreGraphics.CGFloat, alpha: CoreGraphics.CGFloat) {
    get
  }
  public var hexString: Swift.String {
    get
  }
  public var shortHexString: Swift.String? {
    get
  }
  public var shortHexOrHexString: Swift.String {
    get
  }
  public var alpha: CoreGraphics.CGFloat {
    get
  }
  public var coreImageColor: CoreImage.CIColor? {
    get
  }
  public var uInt: Swift.UInt {
    get
  }
  public var complementary: CPCoreKit.Color? {
    get
  }
}
extension UIKit.UIColor {
  public static func blend(_ color1: CPCoreKit.Color, intensity1: CoreGraphics.CGFloat = 0.5, with color2: CPCoreKit.Color, intensity2: CoreGraphics.CGFloat = 0.5) -> CPCoreKit.Color
  public func lighten(by percentage: CoreGraphics.CGFloat = 0.2) -> CPCoreKit.Color
  public func darken(by percentage: CoreGraphics.CGFloat = 0.2) -> CPCoreKit.Color
}
extension UIKit.UIColor {
  convenience public init?(red: Swift.Int, green: Swift.Int, blue: Swift.Int, transparency: CoreGraphics.CGFloat = 1)
  convenience public init?(hex: Swift.Int, transparency: CoreGraphics.CGFloat = 1)
  convenience public init?(hexString: Swift.String, transparency: CoreGraphics.CGFloat = 1)
  convenience public init?(complementaryFor color: CPCoreKit.Color)
}
extension UIKit.UIColor {
  public struct Social {
    public static let facebook: CPCoreKit.Color
    public static let twitter: CPCoreKit.Color
    public static let googlePlus: CPCoreKit.Color
    public static let linkedIn: CPCoreKit.Color
    public static let vimeo: CPCoreKit.Color
    public static let youtube: CPCoreKit.Color
    public static let instagram: CPCoreKit.Color
    public static let pinterest: CPCoreKit.Color
    public static let flickr: CPCoreKit.Color
    public static let yahoo: CPCoreKit.Color
    public static let soundCloud: CPCoreKit.Color
    public static let tumblr: CPCoreKit.Color
    public static let foursquare: CPCoreKit.Color
    public static let swarm: CPCoreKit.Color
    public static let dribbble: CPCoreKit.Color
    public static let reddit: CPCoreKit.Color
    public static let devianArt: CPCoreKit.Color
    public static let pocket: CPCoreKit.Color
    public static let quora: CPCoreKit.Color
    public static let slideShare: CPCoreKit.Color
    public static let px500: CPCoreKit.Color
    public static let listly: CPCoreKit.Color
    public static let vine: CPCoreKit.Color
    public static let skype: CPCoreKit.Color
    public static let stumbleUpon: CPCoreKit.Color
    public static let snapchat: CPCoreKit.Color
    public static let whatsApp: CPCoreKit.Color
  }
}
extension UIKit.UIColor {
  public struct Material {
    public static let red: CPCoreKit.Color
    public static let red50: CPCoreKit.Color
    public static let red100: CPCoreKit.Color
    public static let red200: CPCoreKit.Color
    public static let red300: CPCoreKit.Color
    public static let red400: CPCoreKit.Color
    public static let red500: CPCoreKit.Color
    public static let red600: CPCoreKit.Color
    public static let red700: CPCoreKit.Color
    public static let red800: CPCoreKit.Color
    public static let red900: CPCoreKit.Color
    public static let redA100: CPCoreKit.Color
    public static let redA200: CPCoreKit.Color
    public static let redA400: CPCoreKit.Color
    public static let redA700: CPCoreKit.Color
    public static let pink: CPCoreKit.Color
    public static let pink50: CPCoreKit.Color
    public static let pink100: CPCoreKit.Color
    public static let pink200: CPCoreKit.Color
    public static let pink300: CPCoreKit.Color
    public static let pink400: CPCoreKit.Color
    public static let pink500: CPCoreKit.Color
    public static let pink600: CPCoreKit.Color
    public static let pink700: CPCoreKit.Color
    public static let pink800: CPCoreKit.Color
    public static let pink900: CPCoreKit.Color
    public static let pinkA100: CPCoreKit.Color
    public static let pinkA200: CPCoreKit.Color
    public static let pinkA400: CPCoreKit.Color
    public static let pinkA700: CPCoreKit.Color
    public static let purple: CPCoreKit.Color
    public static let purple50: CPCoreKit.Color
    public static let purple100: CPCoreKit.Color
    public static let purple200: CPCoreKit.Color
    public static let purple300: CPCoreKit.Color
    public static let purple400: CPCoreKit.Color
    public static let purple500: CPCoreKit.Color
    public static let purple600: CPCoreKit.Color
    public static let purple700: CPCoreKit.Color
    public static let purple800: CPCoreKit.Color
    public static let purple900: CPCoreKit.Color
    public static let purpleA100: CPCoreKit.Color
    public static let purpleA200: CPCoreKit.Color
    public static let purpleA400: CPCoreKit.Color
    public static let purpleA700: CPCoreKit.Color
    public static let deepPurple: CPCoreKit.Color
    public static let deepPurple50: CPCoreKit.Color
    public static let deepPurple100: CPCoreKit.Color
    public static let deepPurple200: CPCoreKit.Color
    public static let deepPurple300: CPCoreKit.Color
    public static let deepPurple400: CPCoreKit.Color
    public static let deepPurple500: CPCoreKit.Color
    public static let deepPurple600: CPCoreKit.Color
    public static let deepPurple700: CPCoreKit.Color
    public static let deepPurple800: CPCoreKit.Color
    public static let deepPurple900: CPCoreKit.Color
    public static let deepPurpleA100: CPCoreKit.Color
    public static let deepPurpleA200: CPCoreKit.Color
    public static let deepPurpleA400: CPCoreKit.Color
    public static let deepPurpleA700: CPCoreKit.Color
    public static let indigo: CPCoreKit.Color
    public static let indigo50: CPCoreKit.Color
    public static let indigo100: CPCoreKit.Color
    public static let indigo200: CPCoreKit.Color
    public static let indigo300: CPCoreKit.Color
    public static let indigo400: CPCoreKit.Color
    public static let indigo500: CPCoreKit.Color
    public static let indigo600: CPCoreKit.Color
    public static let indigo700: CPCoreKit.Color
    public static let indigo800: CPCoreKit.Color
    public static let indigo900: CPCoreKit.Color
    public static let indigoA100: CPCoreKit.Color
    public static let indigoA200: CPCoreKit.Color
    public static let indigoA400: CPCoreKit.Color
    public static let indigoA700: CPCoreKit.Color
    public static let blue: CPCoreKit.Color
    public static let blue50: CPCoreKit.Color
    public static let blue100: CPCoreKit.Color
    public static let blue200: CPCoreKit.Color
    public static let blue300: CPCoreKit.Color
    public static let blue400: CPCoreKit.Color
    public static let blue500: CPCoreKit.Color
    public static let blue600: CPCoreKit.Color
    public static let blue700: CPCoreKit.Color
    public static let blue800: CPCoreKit.Color
    public static let blue900: CPCoreKit.Color
    public static let blueA100: CPCoreKit.Color
    public static let blueA200: CPCoreKit.Color
    public static let blueA400: CPCoreKit.Color
    public static let blueA700: CPCoreKit.Color
    public static let lightBlue: CPCoreKit.Color
    public static let lightBlue50: CPCoreKit.Color
    public static let lightBlue100: CPCoreKit.Color
    public static let lightBlue200: CPCoreKit.Color
    public static let lightBlue300: CPCoreKit.Color
    public static let lightBlue400: CPCoreKit.Color
    public static let lightBlue500: CPCoreKit.Color
    public static let lightBlue600: CPCoreKit.Color
    public static let lightBlue700: CPCoreKit.Color
    public static let lightBlue800: CPCoreKit.Color
    public static let lightBlue900: CPCoreKit.Color
    public static let lightBlueA100: CPCoreKit.Color
    public static let lightBlueA200: CPCoreKit.Color
    public static let lightBlueA400: CPCoreKit.Color
    public static let lightBlueA700: CPCoreKit.Color
    public static let cyan: CPCoreKit.Color
    public static let cyan50: CPCoreKit.Color
    public static let cyan100: CPCoreKit.Color
    public static let cyan200: CPCoreKit.Color
    public static let cyan300: CPCoreKit.Color
    public static let cyan400: CPCoreKit.Color
    public static let cyan500: CPCoreKit.Color
    public static let cyan600: CPCoreKit.Color
    public static let cyan700: CPCoreKit.Color
    public static let cyan800: CPCoreKit.Color
    public static let cyan900: CPCoreKit.Color
    public static let cyanA100: CPCoreKit.Color
    public static let cyanA200: CPCoreKit.Color
    public static let cyanA400: CPCoreKit.Color
    public static let cyanA700: CPCoreKit.Color
    public static let teal: CPCoreKit.Color
    public static let teal50: CPCoreKit.Color
    public static let teal100: CPCoreKit.Color
    public static let teal200: CPCoreKit.Color
    public static let teal300: CPCoreKit.Color
    public static let teal400: CPCoreKit.Color
    public static let teal500: CPCoreKit.Color
    public static let teal600: CPCoreKit.Color
    public static let teal700: CPCoreKit.Color
    public static let teal800: CPCoreKit.Color
    public static let teal900: CPCoreKit.Color
    public static let tealA100: CPCoreKit.Color
    public static let tealA200: CPCoreKit.Color
    public static let tealA400: CPCoreKit.Color
    public static let tealA700: CPCoreKit.Color
    public static let green: CPCoreKit.Color
    public static let green50: CPCoreKit.Color
    public static let green100: CPCoreKit.Color
    public static let green200: CPCoreKit.Color
    public static let green300: CPCoreKit.Color
    public static let green400: CPCoreKit.Color
    public static let green500: CPCoreKit.Color
    public static let green600: CPCoreKit.Color
    public static let green700: CPCoreKit.Color
    public static let green800: CPCoreKit.Color
    public static let green900: CPCoreKit.Color
    public static let greenA100: CPCoreKit.Color
    public static let greenA200: CPCoreKit.Color
    public static let greenA400: CPCoreKit.Color
    public static let greenA700: CPCoreKit.Color
    public static let lightGreen: CPCoreKit.Color
    public static let lightGreen50: CPCoreKit.Color
    public static let lightGreen100: CPCoreKit.Color
    public static let lightGreen200: CPCoreKit.Color
    public static let lightGreen300: CPCoreKit.Color
    public static let lightGreen400: CPCoreKit.Color
    public static let lightGreen500: CPCoreKit.Color
    public static let lightGreen600: CPCoreKit.Color
    public static let lightGreen700: CPCoreKit.Color
    public static let lightGreen800: CPCoreKit.Color
    public static let lightGreen900: CPCoreKit.Color
    public static let lightGreenA100: CPCoreKit.Color
    public static let lightGreenA200: CPCoreKit.Color
    public static let lightGreenA400: CPCoreKit.Color
    public static let lightGreenA700: CPCoreKit.Color
    public static let lime: CPCoreKit.Color
    public static let lime50: CPCoreKit.Color
    public static let lime100: CPCoreKit.Color
    public static let lime200: CPCoreKit.Color
    public static let lime300: CPCoreKit.Color
    public static let lime400: CPCoreKit.Color
    public static let lime500: CPCoreKit.Color
    public static let lime600: CPCoreKit.Color
    public static let lime700: CPCoreKit.Color
    public static let lime800: CPCoreKit.Color
    public static let lime900: CPCoreKit.Color
    public static let limeA100: CPCoreKit.Color
    public static let limeA200: CPCoreKit.Color
    public static let limeA400: CPCoreKit.Color
    public static let limeA700: CPCoreKit.Color
    public static let yellow: CPCoreKit.Color
    public static let yellow50: CPCoreKit.Color
    public static let yellow100: CPCoreKit.Color
    public static let yellow200: CPCoreKit.Color
    public static let yellow300: CPCoreKit.Color
    public static let yellow400: CPCoreKit.Color
    public static let yellow500: CPCoreKit.Color
    public static let yellow600: CPCoreKit.Color
    public static let yellow700: CPCoreKit.Color
    public static let yellow800: CPCoreKit.Color
    public static let yellow900: CPCoreKit.Color
    public static let yellowA100: CPCoreKit.Color
    public static let yellowA200: CPCoreKit.Color
    public static let yellowA400: CPCoreKit.Color
    public static let yellowA700: CPCoreKit.Color
    public static let amber: CPCoreKit.Color
    public static let amber50: CPCoreKit.Color
    public static let amber100: CPCoreKit.Color
    public static let amber200: CPCoreKit.Color
    public static let amber300: CPCoreKit.Color
    public static let amber400: CPCoreKit.Color
    public static let amber500: CPCoreKit.Color
    public static let amber600: CPCoreKit.Color
    public static let amber700: CPCoreKit.Color
    public static let amber800: CPCoreKit.Color
    public static let amber900: CPCoreKit.Color
    public static let amberA100: CPCoreKit.Color
    public static let amberA200: CPCoreKit.Color
    public static let amberA400: CPCoreKit.Color
    public static let amberA700: CPCoreKit.Color
    public static let orange: CPCoreKit.Color
    public static let orange50: CPCoreKit.Color
    public static let orange100: CPCoreKit.Color
    public static let orange200: CPCoreKit.Color
    public static let orange300: CPCoreKit.Color
    public static let orange400: CPCoreKit.Color
    public static let orange500: CPCoreKit.Color
    public static let orange600: CPCoreKit.Color
    public static let orange700: CPCoreKit.Color
    public static let orange800: CPCoreKit.Color
    public static let orange900: CPCoreKit.Color
    public static let orangeA100: CPCoreKit.Color
    public static let orangeA200: CPCoreKit.Color
    public static let orangeA400: CPCoreKit.Color
    public static let orangeA700: CPCoreKit.Color
    public static let deepOrange: CPCoreKit.Color
    public static let deepOrange50: CPCoreKit.Color
    public static let deepOrange100: CPCoreKit.Color
    public static let deepOrange200: CPCoreKit.Color
    public static let deepOrange300: CPCoreKit.Color
    public static let deepOrange400: CPCoreKit.Color
    public static let deepOrange500: CPCoreKit.Color
    public static let deepOrange600: CPCoreKit.Color
    public static let deepOrange700: CPCoreKit.Color
    public static let deepOrange800: CPCoreKit.Color
    public static let deepOrange900: CPCoreKit.Color
    public static let deepOrangeA100: CPCoreKit.Color
    public static let deepOrangeA200: CPCoreKit.Color
    public static let deepOrangeA400: CPCoreKit.Color
    public static let deepOrangeA700: CPCoreKit.Color
    public static let brown: CPCoreKit.Color
    public static let brown50: CPCoreKit.Color
    public static let brown100: CPCoreKit.Color
    public static let brown200: CPCoreKit.Color
    public static let brown300: CPCoreKit.Color
    public static let brown400: CPCoreKit.Color
    public static let brown500: CPCoreKit.Color
    public static let brown600: CPCoreKit.Color
    public static let brown700: CPCoreKit.Color
    public static let brown800: CPCoreKit.Color
    public static let brown900: CPCoreKit.Color
    public static let grey: CPCoreKit.Color
    public static let grey50: CPCoreKit.Color
    public static let grey100: CPCoreKit.Color
    public static let grey200: CPCoreKit.Color
    public static let grey300: CPCoreKit.Color
    public static let grey400: CPCoreKit.Color
    public static let grey500: CPCoreKit.Color
    public static let grey600: CPCoreKit.Color
    public static let grey700: CPCoreKit.Color
    public static let grey800: CPCoreKit.Color
    public static let grey900: CPCoreKit.Color
    public static let blueGrey: CPCoreKit.Color
    public static let blueGrey50: CPCoreKit.Color
    public static let blueGrey100: CPCoreKit.Color
    public static let blueGrey200: CPCoreKit.Color
    public static let blueGrey300: CPCoreKit.Color
    public static let blueGrey400: CPCoreKit.Color
    public static let blueGrey500: CPCoreKit.Color
    public static let blueGrey600: CPCoreKit.Color
    public static let blueGrey700: CPCoreKit.Color
    public static let blueGrey800: CPCoreKit.Color
    public static let blueGrey900: CPCoreKit.Color
    public static let black: CPCoreKit.Color
    public static let white: CPCoreKit.Color
  }
}
extension UIKit.UIColor {
  public struct CSS {
    public static let aliceBlue: CPCoreKit.Color
    public static let antiqueWhite: CPCoreKit.Color
    public static let aqua: CPCoreKit.Color
    public static let aquamarine: CPCoreKit.Color
    public static let azure: CPCoreKit.Color
    public static let beige: CPCoreKit.Color
    public static let bisque: CPCoreKit.Color
    public static let black: CPCoreKit.Color
    public static let blanchedAlmond: CPCoreKit.Color
    public static let blue: CPCoreKit.Color
    public static let blueViolet: CPCoreKit.Color
    public static let brown: CPCoreKit.Color
    public static let burlyWood: CPCoreKit.Color
    public static let cadetBlue: CPCoreKit.Color
    public static let chartreuse: CPCoreKit.Color
    public static let chocolate: CPCoreKit.Color
    public static let coral: CPCoreKit.Color
    public static let cornflowerBlue: CPCoreKit.Color
    public static let cornsilk: CPCoreKit.Color
    public static let crimson: CPCoreKit.Color
    public static let cyan: CPCoreKit.Color
    public static let darkBlue: CPCoreKit.Color
    public static let darkCyan: CPCoreKit.Color
    public static let darkGoldenRod: CPCoreKit.Color
    public static let darkGray: CPCoreKit.Color
    public static let darkGrey: CPCoreKit.Color
    public static let darkGreen: CPCoreKit.Color
    public static let darkKhaki: CPCoreKit.Color
    public static let darkMagenta: CPCoreKit.Color
    public static let darkOliveGreen: CPCoreKit.Color
    public static let darkOrange: CPCoreKit.Color
    public static let darkOrchid: CPCoreKit.Color
    public static let darkRed: CPCoreKit.Color
    public static let darkSalmon: CPCoreKit.Color
    public static let darkSeaGreen: CPCoreKit.Color
    public static let darkSlateBlue: CPCoreKit.Color
    public static let darkSlateGray: CPCoreKit.Color
    public static let darkSlateGrey: CPCoreKit.Color
    public static let darkTurquoise: CPCoreKit.Color
    public static let darkViolet: CPCoreKit.Color
    public static let deepPink: CPCoreKit.Color
    public static let deepSkyBlue: CPCoreKit.Color
    public static let dimGray: CPCoreKit.Color
    public static let dimGrey: CPCoreKit.Color
    public static let dodgerBlue: CPCoreKit.Color
    public static let fireBrick: CPCoreKit.Color
    public static let floralWhite: CPCoreKit.Color
    public static let forestGreen: CPCoreKit.Color
    public static let fuchsia: CPCoreKit.Color
    public static let gainsboro: CPCoreKit.Color
    public static let ghostWhite: CPCoreKit.Color
    public static let gold: CPCoreKit.Color
    public static let goldenRod: CPCoreKit.Color
    public static let gray: CPCoreKit.Color
    public static let grey: CPCoreKit.Color
    public static let green: CPCoreKit.Color
    public static let greenYellow: CPCoreKit.Color
    public static let honeyDew: CPCoreKit.Color
    public static let hotPink: CPCoreKit.Color
    public static let indianRed: CPCoreKit.Color
    public static let indigo: CPCoreKit.Color
    public static let ivory: CPCoreKit.Color
    public static let khaki: CPCoreKit.Color
    public static let lavender: CPCoreKit.Color
    public static let lavenderBlush: CPCoreKit.Color
    public static let lawnGreen: CPCoreKit.Color
    public static let lemonChiffon: CPCoreKit.Color
    public static let lightBlue: CPCoreKit.Color
    public static let lightCoral: CPCoreKit.Color
    public static let lightCyan: CPCoreKit.Color
    public static let lightGoldenRodYellow: CPCoreKit.Color
    public static let lightGray: CPCoreKit.Color
    public static let lightGrey: CPCoreKit.Color
    public static let lightGreen: CPCoreKit.Color
    public static let lightPink: CPCoreKit.Color
    public static let lightSalmon: CPCoreKit.Color
    public static let lightSeaGreen: CPCoreKit.Color
    public static let lightSkyBlue: CPCoreKit.Color
    public static let lightSlateGray: CPCoreKit.Color
    public static let lightSlateGrey: CPCoreKit.Color
    public static let lightSteelBlue: CPCoreKit.Color
    public static let lightYellow: CPCoreKit.Color
    public static let lime: CPCoreKit.Color
    public static let limeGreen: CPCoreKit.Color
    public static let linen: CPCoreKit.Color
    public static let magenta: CPCoreKit.Color
    public static let maroon: CPCoreKit.Color
    public static let mediumAquaMarine: CPCoreKit.Color
    public static let mediumBlue: CPCoreKit.Color
    public static let mediumOrchid: CPCoreKit.Color
    public static let mediumPurple: CPCoreKit.Color
    public static let mediumSeaGreen: CPCoreKit.Color
    public static let mediumSlateBlue: CPCoreKit.Color
    public static let mediumSpringGreen: CPCoreKit.Color
    public static let mediumTurquoise: CPCoreKit.Color
    public static let mediumVioletRed: CPCoreKit.Color
    public static let midnightBlue: CPCoreKit.Color
    public static let mintCream: CPCoreKit.Color
    public static let mistyRose: CPCoreKit.Color
    public static let moccasin: CPCoreKit.Color
    public static let navajoWhite: CPCoreKit.Color
    public static let navy: CPCoreKit.Color
    public static let oldLace: CPCoreKit.Color
    public static let olive: CPCoreKit.Color
    public static let oliveDrab: CPCoreKit.Color
    public static let orange: CPCoreKit.Color
    public static let orangeRed: CPCoreKit.Color
    public static let orchid: CPCoreKit.Color
    public static let paleGoldenRod: CPCoreKit.Color
    public static let paleGreen: CPCoreKit.Color
    public static let paleTurquoise: CPCoreKit.Color
    public static let paleVioletRed: CPCoreKit.Color
    public static let papayaWhip: CPCoreKit.Color
    public static let peachPuff: CPCoreKit.Color
    public static let peru: CPCoreKit.Color
    public static let pink: CPCoreKit.Color
    public static let plum: CPCoreKit.Color
    public static let powderBlue: CPCoreKit.Color
    public static let purple: CPCoreKit.Color
    public static let rebeccaPurple: CPCoreKit.Color
    public static let red: CPCoreKit.Color
    public static let rosyBrown: CPCoreKit.Color
    public static let royalBlue: CPCoreKit.Color
    public static let saddleBrown: CPCoreKit.Color
    public static let salmon: CPCoreKit.Color
    public static let sandyBrown: CPCoreKit.Color
    public static let seaGreen: CPCoreKit.Color
    public static let seaShell: CPCoreKit.Color
    public static let sienna: CPCoreKit.Color
    public static let silver: CPCoreKit.Color
    public static let skyBlue: CPCoreKit.Color
    public static let slateBlue: CPCoreKit.Color
    public static let slateGray: CPCoreKit.Color
    public static let slateGrey: CPCoreKit.Color
    public static let snow: CPCoreKit.Color
    public static let springGreen: CPCoreKit.Color
    public static let steelBlue: CPCoreKit.Color
    public static let tan: CPCoreKit.Color
    public static let teal: CPCoreKit.Color
    public static let thistle: CPCoreKit.Color
    public static let tomato: CPCoreKit.Color
    public static let turquoise: CPCoreKit.Color
    public static let violet: CPCoreKit.Color
    public static let wheat: CPCoreKit.Color
    public static let white: CPCoreKit.Color
    public static let whiteSmoke: CPCoreKit.Color
    public static let yellow: CPCoreKit.Color
    public static let yellowGreen: CPCoreKit.Color
  }
}
extension UIKit.UIColor {
  public struct FlatUI {
    public static let turquoise: CPCoreKit.Color
    public static let greenSea: CPCoreKit.Color
    public static let emerald: CPCoreKit.Color
    public static let nephritis: CPCoreKit.Color
    public static let peterRiver: CPCoreKit.Color
    public static let belizeHole: CPCoreKit.Color
    public static let amethyst: CPCoreKit.Color
    public static let wisteria: CPCoreKit.Color
    public static let wetAsphalt: CPCoreKit.Color
    public static let midnightBlue: CPCoreKit.Color
    public static let sunFlower: CPCoreKit.Color
    public static let flatOrange: CPCoreKit.Color
    public static let carrot: CPCoreKit.Color
    public static let pumkin: CPCoreKit.Color
    public static let alizarin: CPCoreKit.Color
    public static let pomegranate: CPCoreKit.Color
    public static let clouds: CPCoreKit.Color
    public static let silver: CPCoreKit.Color
    public static let asbestos: CPCoreKit.Color
    public static let concerte: CPCoreKit.Color
  }
}
@objc @_inheritsConvenienceInitializers public class CPAsynchronousOperation : Foundation.Operation {
  @objc final override public var isReady: Swift.Bool {
    @objc get
  }
  @objc final override public var isExecuting: Swift.Bool {
    @objc get
  }
  @objc final override public var isFinished: Swift.Bool {
    @objc get
  }
  @objc final override public var isAsynchronous: Swift.Bool {
    @objc get
  }
  @objc override final public func start()
  open func execute()
  final public func finish()
  @objc override dynamic public init()
  @objc deinit
}
extension CPCoreKit.Promise {
  public func validate(in context: CPCoreKit.Context? = nil, _ validate: @escaping ((Value) throws -> (Swift.Bool))) -> CPCoreKit.Promise<Value>
}
@_hasMissingDesignatedInitializers public class PredicateRule : CPCoreKit.PasswordRule {
  public var predicate: Foundation.NSPredicate?
  convenience public init(predicate: Foundation.NSPredicate)
  public func evaluate(_ password: Swift.String) -> Swift.Bool
  public var localizedErrorDescription: Swift.String {
    get
  }
  @objc deinit
}
extension CPCoreKit.Promise {
  public func timeout(in context: CPCoreKit.Context? = nil, timeout: Foundation.TimeInterval, error: Swift.Error? = nil) -> CPCoreKit.Promise<Value>
}
extension UIKit.UIScrollView {
  @_Concurrency.MainActor(unsafe) public var snapshot: UIKit.UIImage? {
    get
  }
}
final public class QRCodeReaderViewControllerBuilder {
  public typealias QRCodeReaderViewControllerBuilderBlock = (CPCoreKit.QRCodeReaderViewControllerBuilder) -> Swift.Void
  final public var cancelButtonTitle: Swift.String
  final public var reader: CPCoreKit.QRCodeReader
  final public var readerView: CPCoreKit.QRCodeReaderContainer
  final public var startScanningAtLoad: Swift.Bool
  final public var showCancelButton: Swift.Bool
  final public var showSwitchCameraButton: Swift.Bool {
    get
    set
  }
  final public var showTorchButton: Swift.Bool {
    get
    set
  }
  final public var showOverlayView: Swift.Bool
  final public var handleOrientationChange: Swift.Bool
  final public var preferredStatusBarStyle: UIKit.UIStatusBarStyle?
  final public var rectOfInterest: CoreGraphics.CGRect {
    get
    set
  }
  public init()
  public init(buildBlock: (CPCoreKit.QRCodeReaderViewControllerBuilder) -> Swift.Void)
  @objc deinit
}
public class Strongbox {
  public var lastStatus: Darwin.OSStatus
  public init()
  public init(keyPrefix: Swift.String)
  public func archive(_ object: Any?, key: Swift.String, accessibility: CoreFoundation.CFString = kSecAttrAccessibleWhenUnlocked) -> Swift.Bool
  @discardableResult
  public func remove(key: Swift.String, accessibility: CoreFoundation.CFString = kSecAttrAccessibleWhenUnlocked) -> Swift.Bool
  public func unarchive(objectForKey key: Swift.String) -> Any?
  @objc deinit
}
public enum CPReachabilityError : Swift.Error {
  case FailedToCreateWithAddress(Darwin.sockaddr_in)
  case FailedToCreateWithHostname(Swift.String)
  case UnableToSetCallback
  case UnableToSetDispatchQueue
  case UnableToGetInitialFlags
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension Foundation.NSNotification.Name {
  public static let lcReachabilityChanged: Foundation.Notification.Name
}
public class CPReachability {
  public typealias NetworkReachable = (CPCoreKit.CPReachability) -> ()
  public typealias NetworkUnreachable = (CPCoreKit.CPReachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: CPCoreKit.CPReachability.NetworkStatus, b: CPCoreKit.CPReachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible {
    case none, wifi, cellular
    public var description: Swift.String {
      get
    }
    public static func == (a: CPCoreKit.CPReachability.Connection, b: CPCoreKit.CPReachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: CPCoreKit.CPReachability.NetworkReachable?
  public var whenUnreachable: CPCoreKit.CPReachability.NetworkUnreachable?
  @available(iOS, deprecated: 4.0, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(iOS, deprecated: 4.0, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: CPCoreKit.CPReachability.Connection {
    get
  }
  public var connection: CPCoreKit.CPReachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil)
  convenience public init?(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil)
  convenience public init?(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil)
  @objc deinit
}
extension CPCoreKit.CPReachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(iOS, deprecated: 4.0, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(iOS, deprecated: 4.0, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(iOS, deprecated: 4.0, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
public enum CPCodingKey : Swift.String {
  case clientDescription
  case rolesData
  case personRolesData
  case personCredentialsData
  case contactsData
  case rolesStringArrayData
  case client
  case isRegistered
  case defaultRoleName
  case contact
  case contactType
  case info
  case firstName
  case lastName
  case telephone
  case password
  case personType
  case pin
  case pinValidated
  case preferredLanguage
  case roleNames
  case timeZoneFormatted
  case username
  case uuid
  case contextResponse
  case statusMessage
  case statusCode
  case tenentName
  case tenantName
  case additionalStatusMessage
  case additionalStatusCode
  case responseData
  case notAvailable
  case accountNonLocked
  case accountNonExpired
  case type
  case enabled
  case needChangePassword
  case id
  case remainingChangePasswordDate
  case personRoles
  case status
  case newPassword
  case personContacts
  case credentialsNonExpired
  case personCredentials
  case lastPasswordUpdate
  case lastLoginDatetime
  case currentPassword
  case currentPin
  case newPin
  case createdDate
  case loginAttempt
  case lastUpdatedDate
  case eedChangePassword
  case defaultRole
  case name
  case description
  case role
  case refreshTokenValiditySeconds
  case clientId
  case accessTokenValiditySeconds
  case clientRoleEntitlements
  case clientName
  case authority
  case credentialType
  case credential
  case question
  case answer
  case securityQuestion
  case securityQuestionId
  case userExist
  case last_signon_timestamp
  case user_name
  case user_type
  case userType
  case client_id
  case exp
  case scope
  case tenant_name
  case jti
  case firstname
  case lastname
  case timezone_formatted
  case timezoneFormatted
  case timezoneformatted
  case userContact
  case usercontact
  case contacttype
  case attributes
  case attributesSecureRetrievable
  case containerType
  case token
  case currency
  case isDefault
  case contextRequest
  case containerId
  case moneyContainerId
  case key
  case value
  case moneyContainers
  case offset
  case orderByDate
  case traits
  case max
  case TRANSACTION_START_DATETIME
  case TRANSACTION_END_DATETIME
  case TRANSACTION_DATE
  case entityId
  case confirmationCode
  case transactionAmount
  case transactionTypeName
  case transactionDateTime
  case transactionStatus
  case participants
  case participantRole
  case participantType
  case transactions
  case trxId
  case recipient_moneycontainer_id
  case recipient_amount
  case fee_currency
  case confirmationId
  case sender_name
  case caller_id
  case transaction_create_time
  case sender_moneycontainer_id
  case transactionParticipants
  case transactionDetails
  case person_id
  case participant_type
  case participant_transaction_role
  case first_name
  case last_name
  case moneycontainer_id
  case money_container_type
  case initial_balance
  case new_balance
  case amount
  case amount_sign
  case money_container_num
  case balance
  case availableBalance
  case confirmationInfo
  case confirmationDate
  case timeStamp
  case transactionId
  case transactionInfo
  case subType
  case last4AccountDigits
  case mozidoId
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension CPCoreKit.CPCodingKey {
  public var r: Swift.String {
    get
  }
}
public struct CPImageRequest : Swift.CustomStringConvertible {
  public var urlRequest: Foundation.URLRequest {
    get
    set
  }
  public enum Priority : Swift.Int, Swift.Comparable {
    case veryLow, low, normal, high, veryHigh
    public static func < (lhs: CPCoreKit.CPImageRequest.Priority, rhs: CPCoreKit.CPImageRequest.Priority) -> Swift.Bool
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var priority: CPCoreKit.CPImageRequest.Priority {
    get
    set
  }
  public var options: CPCoreKit.CPImageRequestOptions {
    get
    set
  }
  public var processors: [CPCoreKit.CPImageProcessing] {
    get
    set
  }
  public init(url: Foundation.URL, processors: [CPCoreKit.CPImageProcessing] = [], priority: CPCoreKit.CPImageRequest.Priority = .normal, options: CPCoreKit.CPImageRequestOptions = .init())
  public init(urlRequest: Foundation.URLRequest, processors: [CPCoreKit.CPImageProcessing] = [], priority: CPCoreKit.CPImageRequest.Priority = .normal, options: CPCoreKit.CPImageRequestOptions = .init())
  public var description: Swift.String {
    get
  }
}
public struct CPImageRequestOptions {
  public struct MemoryCacheOptions {
    public var isReadAllowed: Swift.Bool
    public var isWriteAllowed: Swift.Bool
    public init(isReadAllowed: Swift.Bool = true, isWriteAllowed: Swift.Bool = true)
  }
  public var memoryCacheOptions: CPCoreKit.CPImageRequestOptions.MemoryCacheOptions
  public var filteredURL: Swift.String?
  public var cacheKey: Swift.AnyHashable?
  public var loadKey: Swift.AnyHashable?
  public var userInfo: Any?
  public init(memoryCacheOptions: CPCoreKit.CPImageRequestOptions.MemoryCacheOptions = .init(), filteredURL: Swift.String? = nil, cacheKey: Swift.AnyHashable? = nil, loadKey: Swift.AnyHashable? = nil, userInfo: Any? = nil)
}
prefix operator ..
prefix public func .. <T>(promise: CPCoreKit.Promise<T>) throws -> T
prefix operator ..!
prefix public func ..! <T>(promise: CPCoreKit.Promise<T>) -> T?
@discardableResult
public func awaithydra<T>(in context: CPCoreKit.Context? = nil, _ promise: CPCoreKit.Promise<T>) throws -> T
@discardableResult
public func await<T>(in context: CPCoreKit.Context = .background, _ body: @escaping ((_ fulfill: @escaping (T) -> (), _ reject: @escaping (Swift.Error) -> (), _ operation: CPCoreKit.PromiseStatus) throws -> ())) throws -> T
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class QRCodeReaderView : UIKit.UIView, CPCoreKit.QRCodeReaderDisplayable {
  @_Concurrency.MainActor(unsafe) final public var overlayView: UIKit.UIView? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public let cameraView: UIKit.UIView
  @_Concurrency.MainActor(unsafe) final public var cancelButton: UIKit.UIButton? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var switchCameraButton: UIKit.UIButton? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var toggleTorchButton: UIKit.UIButton? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public func setupComponents(with builder: CPCoreKit.QRCodeReaderViewControllerBuilder)
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @objc @_Concurrency.MainActor(unsafe) final public func setNeedsUpdateOrientation()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension Swift.Bool {
  public var int: Swift.Int {
    get
  }
  public var string: Swift.String {
    get
  }
}
extension Swift.Optional {
  public func unwrapped(or defaultValue: Wrapped) -> Wrapped
  public func unwrapped(or error: Swift.Error) throws -> Wrapped
  public func run(_ block: (Wrapped) -> Swift.Void)
  public static func ??= (lhs: inout Swift.Optional<Wrapped>, rhs: Swift.Optional<Wrapped>)
  public static func ?= (lhs: inout Swift.Optional<Wrapped>, rhs: @autoclosure () -> Swift.Optional<Wrapped>)
}
extension Swift.Optional where Wrapped : Swift.Collection {
  public var isNilOrEmpty: Swift.Bool {
    get
  }
  public var nonEmpty: Wrapped? {
    get
  }
}
infix operator ??= : AssignmentPrecedence
infix operator ?= : AssignmentPrecedence
extension Swift.Character {
  public var isEmoji: Swift.Bool {
    get
  }
  public var int: Swift.Int? {
    get
  }
  public var string: Swift.String {
    get
  }
  public var lowercased: Swift.Character {
    get
  }
  public var uppercased: Swift.Character {
    get
  }
}
extension Swift.Character {
  public static func randomAlphanumeric() -> Swift.Character
}
extension Swift.Character {
  public static func * (lhs: Swift.Character, rhs: Swift.Int) -> Swift.String
  public static func * (lhs: Swift.Int, rhs: Swift.Character) -> Swift.String
}
extension CPCoreKit.HTTPHeaders {
  public static func standardHeaders(withSessionAuthorization session: Swift.Bool = false, authorization: Swift.Bool = false, apiKey: Swift.Bool = false) -> [Swift.String : Swift.String]
}
extension CoreGraphics.CGColor {
  public var uiColor: UIKit.UIColor? {
    get
  }
}
extension CPCoreKit.Promise {
  public func retry(_ attempts: Swift.Int = 3, _ condition: @escaping ((Swift.Int, Swift.Error) throws -> Swift.Bool) = { _,_ in true }) -> CPCoreKit.Promise<Value>
}
@available(tvOS 9.2, *)
extension MapKit.MKMapView {
  @_Concurrency.MainActor(unsafe) public func dequeueReusableAnnotationView<T>(withClass name: T.Type) -> T? where T : MapKit.MKAnnotationView
  @available(iOS 11.0, tvOS 11.0, macOS 10.13, *)
  @_Concurrency.MainActor(unsafe) public func register<T>(annotationViewWithClass name: T.Type) where T : MapKit.MKAnnotationView
  @available(iOS 11.0, tvOS 11.0, macOS 10.13, *)
  @_Concurrency.MainActor(unsafe) public func dequeueReusableAnnotationView<T>(withClass name: T.Type, for annotation: MapKit.MKAnnotation) -> T? where T : MapKit.MKAnnotationView
  @_Concurrency.MainActor(unsafe) public func zoom(to coordinates: [CoreLocation.CLLocationCoordinate2D], meter: Swift.Double, edgePadding: CPCoreKit.EdgeInsets, animated: Swift.Bool)
}
extension UIKit.UISlider {
  @_Concurrency.MainActor(unsafe) public func setValue(_ value: Swift.Float, animated: Swift.Bool = true, duration: Foundation.TimeInterval = 1, completion: (() -> Swift.Void)? = nil)
}
extension CoreLocation.CLLocation {
  public static func midLocation(startPush: CoreLocation.CLLocation, end: CoreLocation.CLLocation) -> CoreLocation.CLLocation
  public func midLocation(to point: CoreLocation.CLLocation) -> CoreLocation.CLLocation
  public func bearing(to destination: CoreLocation.CLLocation) -> Swift.Double
}
extension Swift.String {
  public var base64Decoded: Swift.String? {
    get
  }
  public var base64Encoded: Swift.String? {
    get
  }
  public var charactersArray: [Swift.Character] {
    get
  }
  public var camelCased: Swift.String {
    get
  }
  public var containEmoji: Swift.Bool {
    get
  }
  public var firstCharacterAsString: Swift.String? {
    get
  }
  public var hasLetters: Swift.Bool {
    get
  }
  public var hasNumbers: Swift.Bool {
    get
  }
  public var isAlphabetic: Swift.Bool {
    get
  }
  public var isAlphaNumeric: Swift.Bool {
    get
  }
  public var isPalindrome: Swift.Bool {
    get
  }
  public var isValidEmail: Swift.Bool {
    get
  }
  public var isValidUrl: Swift.Bool {
    get
  }
  public var isValidSchemedUrl: Swift.Bool {
    get
  }
  public var isValidHttpsUrl: Swift.Bool {
    get
  }
  public var isValidHttpUrl: Swift.Bool {
    get
  }
  public var isValidFileUrl: Swift.Bool {
    get
  }
  public var isNumeric: Swift.Bool {
    get
  }
  public var isDigits: Swift.Bool {
    get
  }
  public var lastCharacterAsString: Swift.String? {
    get
  }
  public var latinized: Swift.String {
    get
  }
  public var bool: Swift.Bool? {
    get
  }
  public var date: Foundation.Date? {
    get
  }
  public var dateTime: Foundation.Date? {
    get
  }
  public var int: Swift.Int? {
    get
  }
  public static func loremIpsum(ofLength length: Swift.Int = 445) -> Swift.String
  public var url: Foundation.URL? {
    get
  }
  public var trimmed: Swift.String {
    get
  }
  public var urlDecoded: Swift.String {
    get
  }
  public var urlEncoded: Swift.String {
    get
  }
  public var withoutSpacesAndNewLines: Swift.String {
    get
  }
  public var isWhitespace: Swift.Bool {
    get
  }
  public var isSpelledCorrectly: Swift.Bool {
    get
  }
}
extension Swift.String {
  public func float(locale: Foundation.Locale = .current) -> Swift.Float?
  public func double(locale: Foundation.Locale = .current) -> Swift.Double?
  public func cgFloat(locale: Foundation.Locale = .current) -> CoreGraphics.CGFloat?
  public func lines() -> [Swift.String]
  public func localized(comment: Swift.String = "") -> Swift.String
  public func mostCommonCharacter() -> Swift.Character?
  public func unicodeArray() -> [Swift.Int]
  public func words() -> [Swift.String]
  public func wordCount() -> Swift.Int
  public func toSlug() -> Swift.String
  public subscript(safe index: Swift.Int) -> Swift.Character? {
    get
  }
  public subscript(safe range: Swift.CountableRange<Swift.Int>) -> Swift.String? {
    get
  }
  public subscript(safe range: Swift.ClosedRange<Swift.Int>) -> Swift.String? {
    get
  }
  public func copyToPasteboard()
  @discardableResult
  public mutating func camelize() -> Swift.String
  public mutating func firstCharacterUppercased()
  public func hasUniqueCharacters() -> Swift.Bool
  public func containsSubstring(_ string: Swift.String, caseSensitive: Swift.Bool = true) -> Swift.Bool
  public func count(of string: Swift.String, caseSensitive: Swift.Bool = true) -> Swift.Int
  public func ends(with suffix: Swift.String, caseSensitive: Swift.Bool = true) -> Swift.Bool
  @discardableResult
  public mutating func latinize() -> Swift.String
  public static func random(ofLength length: Swift.Int) -> Swift.String
  @discardableResult
  public mutating func reverse() -> Swift.String
  public func slicing(from index: Swift.Int, length: Swift.Int) -> Swift.String?
  @discardableResult
  public mutating func slice(from index: Swift.Int, length: Swift.Int) -> Swift.String
  @discardableResult
  public mutating func slice(from start: Swift.Int, to end: Swift.Int) -> Swift.String
  @discardableResult
  public mutating func slice(at index: Swift.Int) -> Swift.String
  public func starts(with prefix: Swift.String, caseSensitive: Swift.Bool = true) -> Swift.Bool
  public func date(withFormat format: Swift.String) -> Foundation.Date?
  @discardableResult
  public mutating func trim() -> Swift.String
  @discardableResult
  public mutating func truncate(toLength length: Swift.Int, trailing: Swift.String? = "...") -> Swift.String
  public func truncated(toLength length: Swift.Int, trailing: Swift.String? = "...") -> Swift.String
  @discardableResult
  public mutating func urlDecode() -> Swift.String
  @discardableResult
  public mutating func urlEncode() -> Swift.String
  public func matches(pattern: Swift.String) -> Swift.Bool
  @discardableResult
  public mutating func padStart(_ length: Swift.Int, with string: Swift.String = " ") -> Swift.String
  public func paddingStart(_ length: Swift.Int, with string: Swift.String = " ") -> Swift.String
  @discardableResult
  public mutating func padEnd(_ length: Swift.Int, with string: Swift.String = " ") -> Swift.String
  public func paddingEnd(_ length: Swift.Int, with string: Swift.String = " ") -> Swift.String
  public func removingPrefix(_ prefix: Swift.String) -> Swift.String
  public func removingSuffix(_ suffix: Swift.String) -> Swift.String
  public func withPrefix(_ prefix: Swift.String) -> Swift.String
}
extension Swift.String {
  public init?(base64: Swift.String)
  public init(randomOfLength length: Swift.Int)
}
extension Swift.String {
  public var bold: Foundation.NSAttributedString {
    get
  }
  public var underline: Foundation.NSAttributedString {
    get
  }
  public var strikethrough: Foundation.NSAttributedString {
    get
  }
  public var italic: Foundation.NSAttributedString {
    get
  }
  public func colored(with color: CPCoreKit.Color) -> Foundation.NSAttributedString
}
extension Swift.String {
  public static func * (lhs: Swift.String, rhs: Swift.Int) -> Swift.String
  public static func * (lhs: Swift.Int, rhs: Swift.String) -> Swift.String
}
extension Swift.String {
  public var nsString: Foundation.NSString {
    get
  }
  public var lastPathComponent: Swift.String {
    get
  }
  public var pathExtension: Swift.String {
    get
  }
  public var deletingLastPathComponent: Swift.String {
    get
  }
  public var deletingPathExtension: Swift.String {
    get
  }
  public var pathComponents: [Swift.String] {
    get
  }
  public func appendingPathComponent(_ str: Swift.String) -> Swift.String
  public func appendingPathExtension(_ str: Swift.String) -> Swift.String?
}
public protocol CPRequestEndpoint {
  func urlString() -> Swift.String
  func urlString(withUrlParameters parameters: [Swift.String : Swift.String]) -> Swift.String
  func endpoint() -> Swift.String
  var rawValue: Swift.String { get }
  var method: CPCoreKit.CPHTTPMethod { get }
}
extension CPCoreKit.CPRequestEndpoint {
  public var method: CPCoreKit.CPHTTPMethod {
    get
  }
  public func urlString() -> Swift.String
  public func urlString(withUrlParameters parameters: [Swift.String : Swift.String]) -> Swift.String
  public func endpoint() -> Swift.String
}
extension CPCoreKit.Promise {
  public func retryWhen(_ attempts: Swift.Int = 3, _ condition: @escaping ((Swift.Int, Swift.Error) -> CPCoreKit.Promise<Swift.Bool>) = { _,_ in Promise<Bool>(resolved: true) }) -> CPCoreKit.Promise<Value>
}
extension UIKit.UITabBar {
  @_Concurrency.MainActor(unsafe) public func setColors(background: UIKit.UIColor? = nil, selectedBackground: UIKit.UIColor? = nil, item: UIKit.UIColor? = nil, selectedItem: UIKit.UIColor? = nil)
}
extension SpriteKit.SKNode {
  @_Concurrency.MainActor(unsafe) public func descendants() -> [SpriteKit.SKNode]
}
@objc @_inheritsConvenienceInitializers final public class QRCodeReader : ObjectiveC.NSObject, AVFoundation.AVCaptureMetadataOutputObjectsDelegate {
  final public let previewLayer: AVFoundation.AVCaptureVideoPreviewLayer
  final public let metadataObjectTypes: [AVFoundation.AVMetadataObject.ObjectType]
  final public var stopScanningWhenCodeIsFound: Swift.Bool
  final public var didFindCode: ((CPCoreKit.QRCodeReaderResult) -> Swift.Void)?
  final public var didFailDecoding: (() -> Swift.Void)?
  @objc convenience override dynamic public init()
  convenience public init(metadataObjectTypes types: [AVFoundation.AVMetadataObject.ObjectType])
  convenience public init(captureDevicePosition position: AVFoundation.AVCaptureDevice.Position)
  public init(metadataObjectTypes types: [AVFoundation.AVMetadataObject.ObjectType], captureDevicePosition: AVFoundation.AVCaptureDevice.Position)
  @discardableResult
  final public func switchDeviceInput() -> AVFoundation.AVCaptureDeviceInput?
  final public func startScanning()
  final public func stopScanning()
  final public var isRunning: Swift.Bool {
    get
  }
  final public var hasFrontDevice: Swift.Bool {
    get
  }
  final public var isTorchAvailable: Swift.Bool {
    get
  }
  final public func toggleTorch()
  final public class func videoOrientation(deviceOrientation orientation: UIKit.UIDeviceOrientation, withSupportedOrientations supportedOrientations: UIKit.UIInterfaceOrientationMask, fallbackOrientation: AVFoundation.AVCaptureVideoOrientation? = nil) -> AVFoundation.AVCaptureVideoOrientation
  final public class func isAvailable() -> Swift.Bool
  final public class func supportsMetadataObjectTypes(_ metadataTypes: [AVFoundation.AVMetadataObject.ObjectType]? = nil) throws -> Swift.Bool
  @objc final public func metadataOutput(_ output: AVFoundation.AVCaptureMetadataOutput, didOutput metadataObjects: [AVFoundation.AVMetadataObject], from connection: AVFoundation.AVCaptureConnection)
  @objc deinit
}
extension CoreImage.CIColor {
  convenience public init(rgba: Swift.String)
}
extension SceneKit.SCNShape {
  convenience public init(path: UIKit.UIBezierPath, extrusionDepth: CoreGraphics.CGFloat, material: SceneKit.SCNMaterial)
  convenience public init(path: UIKit.UIBezierPath, extrusionDepth: CoreGraphics.CGFloat, color: CPCoreKit.Color)
}
extension Swift.Double {
  public var int: Swift.Int {
    get
  }
  public var float: Swift.Float {
    get
  }
  public var cgFloat: CoreGraphics.CGFloat {
    get
  }
}
extension CPCoreKit.CPImageRequest {
  @available(*, deprecated, message: "Please use `var processors: [ImageProcessing]` instead")
  public var processor: CPCoreKit.CPImageProcessing? {
    get
    set
  }
  @available(*, deprecated, message: "Please use `ImageRequestOptions` instead, it now contains all the advanced options")
  public var memoryCacheOptions: CPCoreKit.CPImageRequestOptions.MemoryCacheOptions {
    get
    set
  }
  @available(*, deprecated, message: "Please use `ImageRequestOptions` instead, it now contains all the advanced options")
  public var cacheKey: Swift.AnyHashable? {
    get
    set
  }
  @available(*, deprecated, message: "Please use `ImageRequestOptions` instead, it now contains all the advanced options")
  public var loadKey: Swift.AnyHashable? {
    get
    set
  }
  @available(*, deprecated, message: "Please use `ImageRequestOptions` instead, it now contains all the advanced options")
  public var userInfo: Any? {
    get
    set
  }
  @available(*, deprecated, message: "Please use the new unified initializer `ImageRequest.init(url:processors:priority:options:)` instead")
  public init(url: Foundation.URL, processor: CPCoreKit.CPImageProcessing)
  @available(*, deprecated, message: "Please use the new unified initializer `ImageRequest.init(urlRequest:processors:priority:options:)` instead")
  public init(urlRequest: Foundation.URLRequest, processor: CPCoreKit.CPImageProcessing)
}
extension CPCoreKit.CPImageRequest {
  @available(*, deprecated, message: "Please use the new unified initializer `ImageRequest.init(urlRequest:processors:priority:options:)` instead or set processors via new `var processors: [ImageProcessing]` property.")
  public mutating func process(with processor: CPCoreKit.CPImageProcessing)
  @available(*, deprecated, message: "Please use the new unified initializer `ImageRequest.init(urlRequest:processors:priority:options:)` instead or set processors via new `var processors: [ImageProcessing]` property.")
  public func processed(with processor: CPCoreKit.CPImageProcessing) -> CPCoreKit.CPImageRequest
  @available(*, deprecated, message: "Please use `ImageProcessor.Anonymous` instead. Key must also be a `String` now")
  public mutating func process(key: Swift.String, _ closure: @escaping (CPCoreKit.CPImage) -> CPCoreKit.CPImage?)
  @available(*, deprecated, message: "Please use `ImageProcessor.Anonymous` instead. Key must also be a `String` now")
  public func processed(key: Swift.String, _ closure: @escaping (CPCoreKit.CPImage) -> CPCoreKit.CPImage?) -> CPCoreKit.CPImageRequest
}
extension CPCoreKit.CPImageRequest {
  @available(*, deprecated, message: "Please use the new unified initializer `ImageRequest.init(url:processors:priority:options:)` with `ImageProcessor.Resize` instead. Target size for `ImageProcessor.Resize` is in points by default, not pixels! For more info see https://github.com/kean/Nuke/pull/229.")
  public init(url: Foundation.URL, targetSize: CoreGraphics.CGSize, contentMode: CPCoreKit.ImageDecompressor.ContentMode, upscale: Swift.Bool = false)
  @available(*, deprecated, message: "Please use the new unified initializer `ImageRequest.init(urlRequest:processors:priority:options:)` with `ImageProcessor.Resize`instead. Target size for `ImageProcessor.Resize` is in points by default, not pixels! For more info see https://github.com/kean/Nuke/pull/229.")
  public init(urlRequest: Foundation.URLRequest, targetSize: CoreGraphics.CGSize, contentMode: CPCoreKit.ImageDecompressor.ContentMode, upscale: Swift.Bool = false)
}
@available(*, deprecated, message: "Decompression now runs automatically after all processors were applied and only if still needed. To disable decompression use `ImagePipeline.Configuration.isDecompressionEnabled`. If you were using `ImageDecompressor` to resize image please use `ImageProcessor.Resize`. Please be aware that the target size for `ImageProcessor.Resize` is in points by default, not pixels like in `ImageDecompressor`! For more info see https://github.com/kean/Nuke/pull/229.")
public struct ImageDecompressor : CPCoreKit.CPImageProcessing {
  public var identifier: Swift.String {
    get
  }
  public var hashableIdentifier: Swift.AnyHashable {
    get
  }
  public enum ContentMode {
    case aspectFill
    case aspectFit
    public static func == (a: CPCoreKit.ImageDecompressor.ContentMode, b: CPCoreKit.ImageDecompressor.ContentMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let MaximumSize: CoreGraphics.CGSize
  public init(targetSize: CoreGraphics.CGSize = MaximumSize, contentMode: CPCoreKit.ImageDecompressor.ContentMode = .aspectFill, upscale: Swift.Bool = false)
  public func process(image: CPCoreKit.CPImage, context: CPCoreKit.CPImageProcessingContext?) -> CPCoreKit.CPImage?
  public static func == (lhs: CPCoreKit.ImageDecompressor, rhs: CPCoreKit.ImageDecompressor) -> Swift.Bool
  public static func targetSize(for view: UIKit.UIView) -> CoreGraphics.CGSize
}
@available(*, deprecated, message: "The new `ImageProcessing` protocol now longer has Self requirement which were previously needed due to `Equatable`, `AnyImageProcessor` is no longer needed")
public struct AnyImageProcessor {
}
extension CPCoreKit.CPImagePipeline {
  @available(*, deprecated, message: "Please use os_signposts instead. For more info see `ImagePipeline.Configuration.isSignpostLoggingEnabled`")
  public var didFinishCollectingMetrics: ((CPCoreKit.CPImageTask, CPCoreKit.ImageTaskMetrics) -> Swift.Void)? {
    get
    set
  }
}
@available(*, deprecated, message: "Please use os_signposts instead. For more info see `ImagePipeline.Configuration.isSignpostLoggingEnabled`")
public struct ImageTaskMetrics : Swift.CustomDebugStringConvertible {
  public let taskId: Swift.Int
  public var wasCancelled: Swift.Bool {
    get
  }
  public var session: CPCoreKit.ImageTaskMetrics.SessionMetrics? {
    get
  }
  public let startDate: Foundation.Date
  public var processStartDate: Foundation.Date? {
    get
  }
  public var processEndDate: Foundation.Date? {
    get
  }
  public var endDate: Foundation.Date? {
    get
  }
  public var totalDuration: Foundation.TimeInterval? {
    get
  }
  public var wasSubscibedToExistingSession: Swift.Bool {
    get
  }
  public var isMemoryCacheHit: Swift.Bool {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @_hasMissingDesignatedInitializers final public class SessionMetrics : Swift.CustomDebugStringConvertible {
    final public let sessionId: Swift.Int
    final public var wasCancelled: Swift.Bool {
      get
    }
    final public let startDate: Foundation.Date
    final public var checkDiskCacheStartDate: Foundation.Date? {
      get
    }
    final public var checkDiskCacheEndDate: Foundation.Date? {
      get
    }
    final public var loadDataStartDate: Foundation.Date? {
      get
    }
    final public var loadDataEndDate: Foundation.Date? {
      get
    }
    final public var decodeStartDate: Foundation.Date? {
      get
    }
    final public var decodeEndDate: Foundation.Date? {
      get
    }
    @available(*, deprecated, message: "Please use the same property on `ImageTaskMetrics` instead.")
    final public var processStartDate: Foundation.Date? {
      get
    }
    @available(*, deprecated, message: "Please use the same property on `ImageTaskMetrics` instead.")
    final public var processEndDate: Foundation.Date? {
      get
    }
    final public var endDate: Foundation.Date? {
      get
    }
    final public var totalDuration: Foundation.TimeInterval? {
      get
    }
    final public var wasResumed: Swift.Bool? {
      get
    }
    final public var resumedDataCount: Swift.Int? {
      get
    }
    final public var serverConfirmedResume: Swift.Bool? {
      get
    }
    final public var downloadedDataCount: Swift.Int? {
      get
    }
    final public var totalDownloadedDataCount: Swift.Int? {
      get
    }
    final public var debugDescription: Swift.String {
      get
    }
    @objc deinit
  }
}
extension CPCoreKit.CPImageTask {
  @available(*, deprecated, message: "Please use `var priority: ImageRequest.Priority`")
  public func setPriority(_ priority: CPCoreKit.CPImageRequest.Priority)
}
@available(iOS 9.0, *)
extension UIKit.UIStackView {
  @_Concurrency.MainActor(unsafe) convenience public init(arrangedSubviews: [UIKit.UIView], axis: UIKit.NSLayoutConstraint.Axis, spacing: CoreGraphics.CGFloat = 0.0, alignment: UIKit.UIStackView.Alignment = .fill, distribution: UIKit.UIStackView.Distribution = .fill)
  @_Concurrency.MainActor(unsafe) public func addArrangedSubviews(_ views: [UIKit.UIView])
  @_Concurrency.MainActor(unsafe) public func removeArrangedSubviews()
}
public enum RandomStringType {
  case numeric
  case alphabet
  case alphanumeric(CAPS_INCLUDED: Swift.Bool)
}
public func randomStringWithLength(len: Swift.Int, stringType: CPCoreKit.RandomStringType) -> Swift.String
public func isDebugging() -> Swift.Bool
public func runOnDebug(_ block: () -> ())
extension Swift.Error {
  public func logCoreDataError(_ msg: Swift.String?)
}
extension Swift.Int {
  public var countableRange: Swift.CountableRange<Swift.Int> {
    get
  }
  public var degreesToRadians: Swift.Double {
    get
  }
  public var radiansToDegrees: Swift.Double {
    get
  }
  public var uInt: Swift.UInt {
    get
  }
  public var double: Swift.Double {
    get
  }
  public var float: Swift.Float {
    get
  }
  public var cgFloat: CoreGraphics.CGFloat {
    get
  }
  public var kFormatted: Swift.String {
    get
  }
  public var digits: [Swift.Int] {
    get
  }
  public var digitsCount: Swift.Int {
    get
  }
}
extension Swift.Int {
  public func isPrime() -> Swift.Bool
  public func romanNumeral() -> Swift.String?
  public func roundToNearest(_ number: Swift.Int) -> Swift.Int
}
extension CPCoreKit.CPJSON {
  public subscript(key: CPCoreKit.CPCodingKey) -> CPCoreKit.CPJSON {
    get
  }
  public func responseDataJson() -> CPCoreKit.CPJSON
  public func responseDataArray() -> [CPCoreKit.CPJSON]
}
extension Foundation.NSCoder {
  public func encode(_ object: Any?, _ k: CPCoreKit.CPCodingKey)
  public func decode(_ k: CPCoreKit.CPCodingKey) -> Any?
}
extension SceneKit.SCNCone {
  convenience public init(topDiameter: CoreGraphics.CGFloat, bottomDiameter: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat)
  convenience public init(topRadius: CoreGraphics.CGFloat, bottomRadius: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, material: SceneKit.SCNMaterial)
  convenience public init(topDiameter: CoreGraphics.CGFloat, bottomDiameter: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, material: SceneKit.SCNMaterial)
  convenience public init(topRadius: CoreGraphics.CGFloat, bottomRadius: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, color: CPCoreKit.Color)
  convenience public init(topDiameter: CoreGraphics.CGFloat, bottomDiameter: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, color: CPCoreKit.Color)
}
@available(tvOS 9.2, *)
extension MapKit.MKPolyline {
  convenience public init(coordinates: [CoreLocation.CLLocationCoordinate2D])
}
@available(tvOS 9.2, *)
extension MapKit.MKPolyline {
  public var coordinates: [CoreLocation.CLLocationCoordinate2D] {
    get
  }
}
extension UIKit.UIAlertController {
  @_Concurrency.MainActor(unsafe) public func show(animated: Swift.Bool = true, vibrate: Swift.Bool = false, completion: (() -> Swift.Void)? = nil)
  @discardableResult
  @_Concurrency.MainActor(unsafe) public func addAction(title: Swift.String, style: UIKit.UIAlertAction.Style = .default, isEnabled: Swift.Bool = true, handler: ((UIKit.UIAlertAction) -> Swift.Void)? = nil) -> UIKit.UIAlertAction
  @_Concurrency.MainActor(unsafe) public func addTextField(text: Swift.String? = nil, placeholder: Swift.String? = nil, editingChangedTarget: Any?, editingChangedSelector: ObjectiveC.Selector?)
}
extension UIKit.UIAlertController {
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String, message: Swift.String? = nil, defaultActionButtonTitle: Swift.String = "OK", tintColor: UIKit.UIColor? = nil)
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "Error", error: Swift.Error, defaultActionButtonTitle: Swift.String = "OK", preferredStyle: UIKit.UIAlertController.Style = .alert, tintColor: UIKit.UIColor? = nil)
}
extension CPCoreKit.CPImagePipeline {
  public struct CPNukeConfiguration {
    public var imageCache: CPCoreKit.CPImageCaching?
    public var dataLoader: CPCoreKit.CPDataLoading
    public var dataCache: CPCoreKit.CPDataCaching?
    public var makeImageDecoder: (CPCoreKit.CPImageDecodingContext) -> CPCoreKit.CPImageDecoding
    public var makeImageEncoder: (CPCoreKit.CPImageEncodingContext) -> CPCoreKit.CPImageEncoding
    public var dataLoadingQueue: Foundation.OperationQueue
    public var dataCachingQueue: Foundation.OperationQueue
    public var imageDecodingQueue: Foundation.OperationQueue
    public var imageEncodingQueue: Foundation.OperationQueue
    public var imageProcessingQueue: Foundation.OperationQueue
    public var imageDecompressingQueue: Foundation.OperationQueue
    public var isDecompressionEnabled: Swift.Bool
    public var isDataCachingForOriginalImageDataEnabled: Swift.Bool
    public var isDataCachingForProcessedImagesEnabled: Swift.Bool
    public var isDeduplicationEnabled: Swift.Bool
    public var isRateLimiterEnabled: Swift.Bool
    public var isProgressiveDecodingEnabled: Swift.Bool
    public var isResumableDataEnabled: Swift.Bool
    public static var isAnimatedImageDataEnabled: Swift.Bool
    public static var isSignpostLoggingEnabled: Swift.Bool
    public init(dataLoader: CPCoreKit.CPDataLoading = CPDataLoader(), imageCache: CPCoreKit.CPImageCaching? = CPImageCache.shared)
  }
}
extension SceneKit.SCNBox {
  convenience public init(width: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, length: CoreGraphics.CGFloat)
  convenience public init(sideLength: CoreGraphics.CGFloat, chamferRadius: CoreGraphics.CGFloat = 0)
  convenience public init(width: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, length: CoreGraphics.CGFloat, chamferRadius: CoreGraphics.CGFloat = 0, material: SceneKit.SCNMaterial)
  convenience public init(sideLength: CoreGraphics.CGFloat, chamferRadius: CoreGraphics.CGFloat = 0, material: SceneKit.SCNMaterial)
  convenience public init(width: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, length: CoreGraphics.CGFloat, chamferRadius: CoreGraphics.CGFloat = 0, color: CPCoreKit.Color)
  convenience public init(sideLength: CoreGraphics.CGFloat, chamferRadius: CoreGraphics.CGFloat = 0, color: CPCoreKit.Color)
}
extension CPCoreKit.Promise {
  public func pass<A>(in context: CPCoreKit.Context? = nil, _ body: @escaping (Value) throws -> CPCoreKit.Promise<A>) -> CPCoreKit.Promise<Value>
  public func pass(in context: CPCoreKit.Context? = nil, _ handler: @escaping (Value) throws -> Swift.Void) -> CPCoreKit.Promise<Value>
}
public enum CPKeyEnvironment : Swift.CustomStringConvertible {
  case development, production
  public var description: Swift.String {
    get
  }
  public static func == (a: CPCoreKit.CPKeyEnvironment, b: CPCoreKit.CPKeyEnvironment) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CPKeys : Swift.CustomStringConvertible {
  var ccurl: Swift.String? { get }
  var merchantid: Swift.String? { get }
  var apikey: Swift.String { get }
  var tenant: Swift.String { get }
  var endpoint: Swift.String { get }
  var environment: CPCoreKit.CPKeyEnvironment { get }
  var appName: Swift.String? { get }
}
extension CPCoreKit.CPKeys {
  public var description: Swift.String {
    get
  }
}
public struct CPKeysConfiguration : CPCoreKit.CPKeys {
  public var ccurl: Swift.String? {
    get
  }
  public var merchantid: Swift.String? {
    get
  }
  public var apikey: Swift.String {
    get
  }
  public var tenant: Swift.String {
    get
  }
  public var endpoint: Swift.String {
    get
  }
  public var environment: CPCoreKit.CPKeyEnvironment {
    get
  }
  public var appName: Swift.String? {
    get
  }
  public init(environment: CPCoreKit.CPKeyEnvironment, endpoint: Swift.String, tenant: Swift.String, apikey: Swift.String, merchantid: Swift.String?, ccurl: Swift.String?, appName: Swift.String?)
}
extension Swift.BinaryFloatingPoint {
  public func rounded(numberOfDecimalPlaces: Swift.Int, rule: Swift.FloatingPointRoundingRule) -> Self
}
extension Swift.KeyedDecodingContainer {
  public func decodeBoolAsIntOrString(forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Bool
  public func decodeBoolAsIntOrStringIfPresent(forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Bool?
}
extension SceneKit.SCNMaterial {
  convenience public init(color: CPCoreKit.Color)
}
@_hasMissingDesignatedInitializers final public class CPCore {
  public static var notificationid: Swift.String?
  public static func setValue(_ val: Any, s: Swift.String)
  @objc deinit
}
public struct CPConfiguration {
  public let log: Swift.Bool
  public let tenant: Swift.String
  public let endpoint: Swift.String
  public let apiSecret: Swift.String
  public let apiVersion: Swift.String
  public let currencyNumber: Swift.String
  public let ccurl: Swift.String?
  public let merchantid: Swift.String?
  public let appName: Swift.String?
  public let isDevelopment: Swift.Bool
  public var valid: Swift.Bool {
    get
  }
  public init(_ d: CPCoreKit.CPJSON)
}
extension Swift.FloatingPoint {
  public var abs: Self {
    get
  }
  public var isPositive: Swift.Bool {
    get
  }
  public var isNegative: Swift.Bool {
    get
  }
  public var ceil: Self {
    get
  }
  public var degreesToRadians: Self {
    get
  }
  public var floor: Self {
    get
  }
  public var radiansToDegrees: Self {
    get
  }
}
public typealias 🔳 = CPCoreKit.CPQRCode
public struct CPQRCode {
  public enum ErrorCorrection : Swift.String {
    case Low
    case Medium
    case Quartile
    case High
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let data: Foundation.Data
  public var color: CoreImage.CIColor
  public var backgroundColor: CoreImage.CIColor
  public var size: CoreGraphics.CGSize
  public var errorCorrection: CPCoreKit.CPQRCode.ErrorCorrection
  public init(_ data: Foundation.Data)
  public init?(_ string: Swift.String)
  public init?(_ url: Foundation.URL)
  public var image: UIKit.UIImage? {
    get
  }
  public var ciImage: CoreImage.CIImage? {
    get
  }
}
public func zip<A, B>(in context: CPCoreKit.Context? = nil, _ a: CPCoreKit.Promise<A>, _ b: CPCoreKit.Promise<B>) -> CPCoreKit.Promise<(A, B)>
public func zip<A, B, C>(in context: CPCoreKit.Context? = nil, a: CPCoreKit.Promise<A>, b: CPCoreKit.Promise<B>, c: CPCoreKit.Promise<C>) -> CPCoreKit.Promise<(A, B, C)>
public func zip<A, B, C, D>(in context: CPCoreKit.Context? = nil, a: CPCoreKit.Promise<A>, b: CPCoreKit.Promise<B>, c: CPCoreKit.Promise<C>, d: CPCoreKit.Promise<D>) -> CPCoreKit.Promise<(A, B, C, D)>
public struct QRCodeReaderResult {
  public let value: Swift.String
  public let metadataType: Swift.String
}
extension Foundation.Data {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Foundation.Data {
  public func string(encoding: Swift.String.Encoding) -> Swift.String?
  public func jsonObject(options: Foundation.JSONSerialization.ReadingOptions = []) throws -> Any
}
public struct Formatters {
  public static let shortDateFormatterMonthAbbreviationAndDay: Foundation.DateFormatter
  public static let shortDateFormatterMonthAbbreviationDayYY: Foundation.DateFormatter
  public static let shortDateFormatterMonthAbbreviationDayYYYY: Foundation.DateFormatter
  public static let monthNameDayAndYear: Foundation.DateFormatter
  public static let monthNumberDayAndYear: Foundation.DateFormatter
  public static let monthNumberDayNumberAndFullYearSlashed: Foundation.DateFormatter
  public static let dayMonthAbbrebiationYear: Foundation.DateFormatter
  public static let monthNameDayAndShortYear: Foundation.DateFormatter
  public static let monthAbbrDayNumberYearTime: Foundation.DateFormatter
  public static let moneyFormatter: Foundation.NumberFormatter
  public static let doubleFormatter: Foundation.NumberFormatter
  public static let moneyFormatter2: Foundation.NumberFormatter
}
final public class CPImagePreheater {
  public enum Destination {
    case memoryCache
    case diskCache
    public static func == (a: CPCoreKit.CPImagePreheater.Destination, b: CPCoreKit.CPImagePreheater.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(pipeline: CPCoreKit.CPImagePipeline = CPImagePipeline.shared, destination: CPCoreKit.CPImagePreheater.Destination = .memoryCache, maxConcurrentRequestCount: Swift.Int = 2)
  final public func startPreheating(with urls: [Foundation.URL])
  final public func startPreheating(with requests: [CPCoreKit.CPImageRequest])
  final public func stopPreheating(with urls: [Foundation.URL])
  final public func stopPreheating(with requests: [CPCoreKit.CPImageRequest])
  final public func stopPreheating()
  @objc deinit
}
extension UIKit.UIColor {
  @available(iOS 13.0, tvOS 13.0, *)
  convenience public init(light: UIKit.UIColor, dark: UIKit.UIColor)
}
public enum CPDefaultsKey : Swift.String {
  case location
  case reviewQuery
  case username
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct CPDefaults {
  public static func removeObject(for key: CPCoreKit.CPDefaultsKey)
  public static func setValue(_ value: Any, forKey key: CPCoreKit.CPDefaultsKey)
  public static func getValue<T>(for key: CPCoreKit.CPDefaultsKey) -> T?
  @discardableResult
  public static func setCustomObject<T>(_ value: T, forKey key: CPCoreKit.CPDefaultsKey) -> Swift.Bool where T : ObjectiveC.NSObject, T : Foundation.NSCoding
  public static func getCustomObject<T>(for key: CPCoreKit.CPDefaultsKey) -> T? where T : ObjectiveC.NSObject, T : Foundation.NSCoding
  public static func getImage(named name: Swift.String) -> UIKit.UIImage?
  public static func saveImage(image: UIKit.UIImage?, forName key: Swift.String)
}
extension CPCoreKit.Promise {
  indirect public enum Observer {
    public typealias ResolveObserver = ((Value) -> ())
    public typealias RejectObserver = ((Swift.Error) -> ())
    public typealias CancelObserver = (() -> ())
    case onResolve(CPCoreKit.Context, CPCoreKit.Promise<Value>.Observer.ResolveObserver)
    case onReject(CPCoreKit.Context, CPCoreKit.Promise<Value>.Observer.RejectObserver)
    case onCancel(CPCoreKit.Context, CPCoreKit.Promise<Value>.Observer.CancelObserver)
  }
}
public protocol CPCancellable : AnyObject {
  func cancel()
}
public protocol CPDataLoading {
  func loadData(with request: Foundation.URLRequest, didReceiveData: @escaping (Foundation.Data, Foundation.URLResponse) -> Swift.Void, completion: @escaping (Swift.Error?) -> Swift.Void) -> CPCoreKit.CPCancellable
}
extension Foundation.URLSessionTask : CPCoreKit.CPCancellable {
}
final public class CPDataLoader : CPCoreKit.CPDataLoading {
  final public let session: Foundation.URLSession
  public init(configuration: Foundation.URLSessionConfiguration = CPDataLoader.defaultConfiguration, validate: @escaping (Foundation.URLResponse) -> Swift.Error? = CPDataLoader.validate)
  public static var defaultConfiguration: Foundation.URLSessionConfiguration {
    get
  }
  public static func validate(response: Foundation.URLResponse) -> Swift.Error?
  public static let sharedUrlCache: Foundation.URLCache
  final public func loadData(with request: Foundation.URLRequest, didReceiveData: @escaping (Foundation.Data, Foundation.URLResponse) -> Swift.Void, completion: @escaping (Swift.Error?) -> Swift.Void) -> CPCoreKit.CPCancellable
  public enum Error : Swift.Error, Swift.CustomDebugStringConvertible {
    case statusCodeUnacceptable(Swift.Int)
    public var debugDescription: Swift.String {
      get
    }
  }
  @objc deinit
}
extension UIKit.UILabel {
  @_Concurrency.MainActor(unsafe) convenience public init(text: Swift.String?)
  @_Concurrency.MainActor(unsafe) convenience public init(text: Swift.String, style: UIKit.UIFont.TextStyle)
  @_Concurrency.MainActor(unsafe) public var requiredHeight: CoreGraphics.CGFloat {
    get
  }
}
extension UIKit.UIRefreshControl {
  @_Concurrency.MainActor(unsafe) public func beginRefreshing(in tableView: UIKit.UITableView, animated: Swift.Bool, sendAction: Swift.Bool = false)
}
extension Swift.SignedNumeric {
  public var string: Swift.String {
    get
  }
  public var asLocaleCurrency: Swift.String? {
    get
  }
}
extension Swift.SignedNumeric {
  public func spelledOutString(locale: Foundation.Locale = .current) -> Swift.String?
}
extension Swift.SignedInteger {
  public var abs: Self {
    get
  }
  public var isPositive: Swift.Bool {
    get
  }
  public var isNegative: Swift.Bool {
    get
  }
  public var isEven: Swift.Bool {
    get
  }
  public var isOdd: Swift.Bool {
    get
  }
  public var timeString: Swift.String {
    get
  }
}
extension Swift.SignedInteger {
  public func gcd(of number: Self) -> Self
  public func lcm(of number: Self) -> Self
  @available(iOS 9.0, macOS 10.11, *)
  public func ordinalString(locale: Foundation.Locale = .current) -> Swift.String?
}
extension UIKit.UIWindow {
  @_Concurrency.MainActor(unsafe) public func switchRootViewController(to viewController: UIKit.UIViewController, animated: Swift.Bool = true, duration: Foundation.TimeInterval = 0.5, options: UIKit.UIView.AnimationOptions = .transitionFlipFromRight, _ completion: (() -> Swift.Void)? = nil)
}
public func any<L>(in context: CPCoreKit.Context? = nil, _ promises: CPCoreKit.Promise<L>...) -> CPCoreKit.Promise<L>
public func any<L>(in context: CPCoreKit.Context? = nil, _ promises: [CPCoreKit.Promise<L>]) -> CPCoreKit.Promise<L>
public protocol DialCountriesControllerDelegate : AnyObject {
  func didSelected(with country: CPCoreKit.Country)
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class DialCountriesController : UIKit.UITableViewController, UIKit.UISearchResultsUpdating {
  @_Concurrency.MainActor(unsafe) weak public var delegate: CPCoreKit.DialCountriesControllerDelegate?
  @_Concurrency.MainActor(unsafe) public var showFlags: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var onCountrySelected: ((CPCoreKit.Country) -> ())?
  @_Concurrency.MainActor(unsafe) public var styleColor: UIKit.UIColor?
  @_Concurrency.MainActor(unsafe) public init(locale: Foundation.Locale)
  @_Concurrency.MainActor(unsafe) public func show(vc: UIKit.UIViewController)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc public func updateSearchResults(for searchController: UIKit.UISearchController)
  @objc deinit
}
extension UIKit.UINavigationController {
  @_Concurrency.MainActor(unsafe) public func popViewController(animated: Swift.Bool = true, _ completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func pushViewController(_ viewController: UIKit.UIViewController, completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func makeTransparent(withTint tint: UIKit.UIColor = .white)
}
@objc @_Concurrency.MainActor(unsafe) public class QRCodeReaderViewController : UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public var codeReader: CPCoreKit.QRCodeReader {
    get
  }
  @_Concurrency.MainActor(unsafe) weak public var delegate: CPCoreKit.QRCodeReaderViewControllerDelegate?
  @_Concurrency.MainActor(unsafe) public var completionBlock: ((CPCoreKit.QRCodeReaderResult?) -> Swift.Void)?
  @objc deinit
  @_Concurrency.MainActor(unsafe) required public init(builder: CPCoreKit.QRCodeReaderViewControllerBuilder)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillLayoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @_Concurrency.MainActor(unsafe) @objc get
  }
  @_Concurrency.MainActor(unsafe) public func startScanning()
  @_Concurrency.MainActor(unsafe) public func stopScanning()
}
extension UIKit.UINavigationItem {
  @_Concurrency.MainActor(unsafe) public func replaceTitle(with image: UIKit.UIImage)
}
public func async<T>(in context: CPCoreKit.Context? = nil, token: CPCoreKit.InvalidationToken? = nil, _ body: @escaping ((_ status: CPCoreKit.PromiseStatus) throws -> (T))) -> CPCoreKit.Promise<T>
public func async(in context: CPCoreKit.Context, after: Foundation.TimeInterval? = nil, _ block: @escaping () -> ())
extension UIKit.UITextView {
  @_Concurrency.MainActor(unsafe) public func clear()
  @_Concurrency.MainActor(unsafe) public func scrollToBottom()
  @_Concurrency.MainActor(unsafe) public func scrollToTop()
  @_Concurrency.MainActor(unsafe) public func wrapToContent()
}
extension CPCoreKit.CPImageProcessor.Unit : Swift.Equatable {}
extension CPCoreKit.CPImageProcessor.Unit : Swift.Hashable {}
extension CPCoreKit.CPImageProcessor.Resize.ContentMode : Swift.Equatable {}
extension CPCoreKit.CPImageProcessor.Resize.ContentMode : Swift.Hashable {}
extension CPCoreKit.CPSwiftyJSONError : Swift.Equatable {}
extension CPCoreKit.CPSwiftyJSONError : Swift.Hashable {}
extension CPCoreKit.CPSwiftyJSONError : Swift.RawRepresentable {}
extension CPCoreKit.CPType : Swift.Equatable {}
extension CPCoreKit.CPType : Swift.Hashable {}
extension CPCoreKit.CPType : Swift.RawRepresentable {}
extension CPCoreKit.writingOptionsKeys : Swift.Equatable {}
extension CPCoreKit.writingOptionsKeys : Swift.Hashable {}
extension CPCoreKit.PromiseError : Swift.Equatable {}
extension CPCoreKit.PromiseError : Swift.Hashable {}
extension CPCoreKit.PasswordStrength : Swift.Equatable {}
extension CPCoreKit.PasswordStrength : Swift.Hashable {}
extension UIKit.UITextField.TextType : Swift.Equatable {}
extension UIKit.UITextField.TextType : Swift.Hashable {}
extension CPCoreKit.RequiredCharacterRulePreset : Swift.Equatable {}
extension CPCoreKit.RequiredCharacterRulePreset : Swift.Hashable {}
extension CPCoreKit.CPHTTPMethod : Swift.Equatable {}
extension CPCoreKit.CPHTTPMethod : Swift.Hashable {}
extension CPCoreKit.CPHTTPMethod : Swift.RawRepresentable {}
extension CPCoreKit.CPHTTPProgress.`Type` : Swift.Equatable {}
extension CPCoreKit.CPHTTPProgress.`Type` : Swift.Hashable {}
extension UIKit.UIApplication.Environment : Swift.Equatable {}
extension UIKit.UIApplication.Environment : Swift.Hashable {}
extension CPCoreKit.AuthenticationType : Swift.Equatable {}
extension CPCoreKit.AuthenticationType : Swift.Hashable {}
extension CPCoreKit.ContentHeaderType : Swift.Equatable {}
extension CPCoreKit.ContentHeaderType : Swift.Hashable {}
extension CPCoreKit.CPInvalidRequestSource : Swift.Equatable {}
extension CPCoreKit.CPInvalidRequestSource : Swift.Hashable {}
extension CPCoreKit.CPInvalidRequestSource : Swift.RawRepresentable {}
extension Foundation.Formatter.DayOfMonth : Swift.Equatable {}
extension Foundation.Formatter.DayOfMonth : Swift.Hashable {}
extension UIKit.UIView.ShakeDirection : Swift.Equatable {}
extension UIKit.UIView.ShakeDirection : Swift.Hashable {}
extension UIKit.UIView.AngleUnit : Swift.Equatable {}
extension UIKit.UIView.AngleUnit : Swift.Hashable {}
extension UIKit.UIView.ShakeAnimationType : Swift.Equatable {}
extension UIKit.UIView.ShakeAnimationType : Swift.Hashable {}
extension CPCoreKit.CPSortOrder : Swift.Equatable {}
extension CPCoreKit.CPSortOrder : Swift.Hashable {}
extension CPCoreKit.CPSortOrder : Swift.RawRepresentable {}
extension Foundation.Date.DayNameStyle : Swift.Equatable {}
extension Foundation.Date.DayNameStyle : Swift.Hashable {}
extension Foundation.Date.MonthNameStyle : Swift.Equatable {}
extension Foundation.Date.MonthNameStyle : Swift.Hashable {}
extension CPCoreKit.PromiseResolveType : Swift.Equatable {}
extension CPCoreKit.PromiseResolveType : Swift.Hashable {}
@available(*, unavailable, renamed: "Connection")
extension CPCoreKit.CPReachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Connection")
extension CPCoreKit.CPReachability.NetworkStatus : Swift.Hashable {}
extension CPCoreKit.CPReachability.Connection : Swift.Equatable {}
extension CPCoreKit.CPReachability.Connection : Swift.Hashable {}
extension CPCoreKit.CPCodingKey : Swift.Equatable {}
extension CPCoreKit.CPCodingKey : Swift.Hashable {}
extension CPCoreKit.CPCodingKey : Swift.RawRepresentable {}
extension CPCoreKit.CPImageRequest.Priority : Swift.Hashable {}
extension CPCoreKit.CPImageRequest.Priority : Swift.RawRepresentable {}
@available(*, deprecated, message: "Decompression now runs automatically after all processors were applied and only if still needed. To disable decompression use `ImagePipeline.Configuration.isDecompressionEnabled`. If you were using `ImageDecompressor` to resize image please use `ImageProcessor.Resize`. Please be aware that the target size for `ImageProcessor.Resize` is in points by default, not pixels like in `ImageDecompressor`! For more info see https://github.com/kean/Nuke/pull/229.")
extension CPCoreKit.ImageDecompressor.ContentMode : Swift.Equatable {}
@available(*, deprecated, message: "Decompression now runs automatically after all processors were applied and only if still needed. To disable decompression use `ImagePipeline.Configuration.isDecompressionEnabled`. If you were using `ImageDecompressor` to resize image please use `ImageProcessor.Resize`. Please be aware that the target size for `ImageProcessor.Resize` is in points by default, not pixels like in `ImageDecompressor`! For more info see https://github.com/kean/Nuke/pull/229.")
extension CPCoreKit.ImageDecompressor.ContentMode : Swift.Hashable {}
extension CPCoreKit.CPKeyEnvironment : Swift.Equatable {}
extension CPCoreKit.CPKeyEnvironment : Swift.Hashable {}
extension CPCoreKit.CPQRCode.ErrorCorrection : Swift.Equatable {}
extension CPCoreKit.CPQRCode.ErrorCorrection : Swift.Hashable {}
extension CPCoreKit.CPQRCode.ErrorCorrection : Swift.RawRepresentable {}
extension CPCoreKit.CPImagePreheater.Destination : Swift.Equatable {}
extension CPCoreKit.CPImagePreheater.Destination : Swift.Hashable {}
extension CPCoreKit.CPDefaultsKey : Swift.Equatable {}
extension CPCoreKit.CPDefaultsKey : Swift.Hashable {}
extension CPCoreKit.CPDefaultsKey : Swift.RawRepresentable {}
